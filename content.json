{"meta":{"title":"Fengx","subtitle":"冯晓的博客","description":"冯晓的博客","author":"Fengx","url":"http://example.com"},"pages":[{"title":"tags","date":"2021-08-13T06:55:00.000Z","updated":"2021-08-13T06:55:00.397Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-13T06:55:07.000Z","updated":"2021-08-13T06:55:07.722Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Boot+Dubbo 入门","slug":"springboot2","date":"2021-08-26T14:21:21.000Z","updated":"2021-08-26T14:29:01.199Z","comments":false,"path":"2021/08/26/springboot2/","link":"","permalink":"http://example.com/2021/08/26/springboot2/","excerpt":"","text":"Dubbo 架构 一：zookeeper 环境安装搭建1、搭建 zookeeper 之前要确保当前的机器已经有 JDK 环境。 2、将 conf 目录下 zoo_sample.cfg 文件重命名为 zoo.cfg 二 ：实现服务接口 dubbo-interface主要分为下面几步： 创建 Maven 项目; 创建接口类 将项目打成 jar 包供其他项目使用 项目结构： dubbo-interface 后面被打成 jar 包，它的作用只是提供接口。 1. dubbo-interface 项目创建File-&gt;New-&gt;Module… ,然后选择 Maven类型的项目，其他的按照提示一步一步走就好。 2. 创建接口类1234567891011package com.fengx.service;/** * @author: Fengx * @date: 2021-07-21 * @description: 服务接口 **/public interface HelloService &#123; String sayHello(String name);&#125; 3. 将项目打成 jar 包供其他项目使用点击右边的 Maven Projects 然后选择 install ，这样 jar 包就打好了。 三 ：实现服务提供者 dubbo-provider主要分为下面几步： 创建 springboot 项目; 加入 dubbo 、zookeeper以及接口的相关依赖 jar 包； 在 application.properties 配置文件中配置 dubbo 相关信息； 实现接口类; 服务提供者启动类编写 项目结构： 1. dubbo-provider 项目创建创建一个 SpringBoot 项目，注意勾选上 web 模块。 2. pom 文件引入相关依赖需要引入 dubbo 、zookeeper以及接口的相关依赖 jar 包。注意将本项目和 dubbo-interface 项目的 dependency 依赖的 groupId 和 artifactId 改成自己的。dubbo 整合spring boot 的 jar 包在这里找dubbo-spring-boot-starter。zookeeper 的 jar包在 Maven 仓库 搜索 zkclient 即可找到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.fengx&lt;/groupId&gt; &lt;artifactId&gt;dubbo-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;dubbo-provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fengx&lt;/groupId&gt; &lt;artifactId&gt;dubbo-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入dubbo的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入zookeeper的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3. 在 application.properties 配置文件中配置 dubbo 相关信息配置很简单，这主要得益于 springboot 整合 dubbo 专属的@EnableDubboConfiguration 注解提供的 Dubbo 自动配置。 12345# 配置端口server.port=8333spring.dubbo.application.name=dubbo-providerspring.dubbo.application.registry=zookeeper://127.0.0.1:2181 4. 实现接口注意： @Service 注解使用的时 Dubbo 提供的而不是 Spring 提供的。另外，加了Dubbo 提供的 @Service 注解之后还需要加入 1234567891011121314151617181920package com.fengx.dubboprovider.service.impl;import com.alibaba.dubbo.config.annotation.Service;import com.fengx.service.HelloService;import org.springframework.stereotype.Component;/** * @author: Fengx * @date: 2021-07-21 * @description: 服务接口实现 **/@Component@Servicepublic class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return &quot;Hello &quot; + name; &#125;&#125; 5. 服务提供者启动类编写注意：不要忘记加上 @EnableDubboConfiguration 注解开启Dubbo 的自动配置。 123456789101112131415161718package com.fengx.dubboprovider;import com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 服务提供者 */@SpringBootApplication// 开启dubbo的自动配置@EnableDubboConfigurationpublic class DubboProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboProviderApplication.class, args); &#125;&#125; 四：实现服务消费者 dubbo-consumer主要分为下面几步： 创建 springboot 项目; 加入 dubbo 、zookeeper以及接口的相关依赖 jar 包； 在 application.properties 配置文件中配置 dubbo 相关信息； 编写测试类; 服务消费者启动类编写 测试效果 项目结构： 1. dubbo-consumer 项目创建创建一个 SpringBoot 项目，注意勾选上 web 模块。 2. pom 文件引入相关依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.fengx&lt;/groupId&gt; &lt;artifactId&gt;dubbo-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;dubbo-consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--引入接口项目jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fengx&lt;/groupId&gt; &lt;artifactId&gt;dubbo-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入dubbo的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入zookeeper的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3. 在 application.properties 配置文件中配置 dubbo 相关信息配置很简单，这主要得益于 springboot 整合 dubbo 专属的@EnableDubboConfiguration 注解提供的 Dubbo 自动配置。 12345# 配置端口server.port=8330spring.dubbo.application.name=dubbo-consumerspring.dubbo.application.registry=zookeeper://127.0.0.1:2181 4. 编写一个简单 Controller 调用远程服务12345678910111213141516171819202122232425package com.fengx.dubboconsumer.controller;import com.alibaba.dubbo.config.annotation.Reference;import com.fengx.service.HelloService;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author: Fengx * @date: 2021-07-21 * @description: 调用远程服务 **/@RestControllerpublic class HelloController &#123; @Reference private HelloService helloService; @RequestMapping(&quot;/hello&quot;) public String hello() &#123; String hello = helloService.sayHello(&quot;world&quot;); System.out.println(helloService.sayHello(&quot;fengx&quot;)); return hello; &#125;&#125; 5. 服务消费者启动类编写1234567891011121314package com.fengx.dubboconsumer;import com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@EnableDubboConfigurationpublic class DubboConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboConsumerApplication.class, args); &#125;&#125; 6. 测试效果浏览器访问 http://localhost:8330/hello 页面返回 Hello world，控制台输出 Hello fengx，和预期一致，使用SpringBoot+Dubbo 搭建第一个简单的分布式服务实验成功！ 参考：https://github.com/CodingDocs/springboot-guide/blob/master/docs/advanced/springboot-dubbo.md","categories":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://example.com/categories/Dubbo/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://example.com/tags/Spring-Boot/"},{"name":"Dubbo","slug":"Dubbo","permalink":"http://example.com/tags/Dubbo/"}],"keywords":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://example.com/categories/Dubbo/"}]},{"title":"Go 代码记录（一）","slug":"go1","date":"2021-08-20T13:32:22.000Z","updated":"2021-08-20T13:37:39.360Z","comments":false,"path":"2021/08/20/go1/","link":"","permalink":"http://example.com/2021/08/20/go1/","excerpt":"","text":"1、hello world！12345678910// 同一个目录下面不能有个多 package mainpackage main// 导包import &quot;fmt&quot;// 程序入口func main() &#123; fmt.Println(&quot;Hello world&quot;)&#125; 2、HTTP文件服务器123456789101112131415161718192021// 标记当前文件为 main 包，main 包也是 Go 程序的入口包package main// 导入 net/http 包，这个包的作用是 HTTP 的基础封装和访问import ( &quot;net/http&quot;)/**HTTP文件服务器*/// 程序执行的入口函数 main()func main() &#123; // 使用 http.FileServer 文件服务器将当前目录作为根目录（/目录）的处理器，访问根目录，就会进入当前目录 http.Handle(&quot;/&quot;, http.FileServer(http.Dir(&quot;.&quot;))) // 默认的 HTTP 服务侦听在本机 8080 端口 http.ListenAndServe(&quot;:8080&quot;, nil)&#125;// 在浏览器里输入http://127.0.0.1:8080即可浏览文件，这些文件正是当前目录在HTTP服务器上的映射目录。 3、并发编程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 同一个目录下面不能有个多 package mainpackage main// 导入格式化（fmt）、随机数（math/rand）、时间（time）包参与编译import ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)// 生产数据的函数，传入一个标记类型的字符串及一个只能写入的通道// 数据生产者func producer(header string, channel chan&lt;- string) &#123; // for&#123;&#125; 构成一个无限循环 // 无限循环，不停地生产数据 for &#123; // 使用 rand.Int31() 生成一个随机数，使用 fmt.Sprintf() 函数将 header 和随机数格式化为字符串 // 将随机数和字符串格式化为字符串发送给通道 channel &lt;- fmt.Sprintf(&quot;%s: %v&quot;, header, rand.Int31()) // 使用 time.Sleep() 函数暂停 1 秒再执行这个函数。如果在 goroutine 中执行时，暂停不会影响其他 goroutine 的执行 // 等待1秒 time.Sleep(time.Second) &#125;&#125;// 消费数据的函数，传入一个只能写入的通道// 数据消费者func customer(channel &lt;-chan string) &#123; // 不停的获取数据 for &#123; // 从通道中获取数据，此处会阻塞直到信道中返回数据 message := &lt;-channel // 打印数据 fmt.Println(message) &#125;&#125;// 程序的入口函数，总是在程序开始时执行func main() &#123; // 创建一个字符串类型的通道 channel := make(chan string) // 并发执行一个生产者函数，两行分别创建了这个函数搭配不同参数的两个 goroutine // 创建producer()函数的并发goroutine go producer(&quot;cat&quot;, channel) go producer(&quot;dog&quot;, channel) // 执行消费者函数通过通道进行数据消费 // 数据消费函数 customer(channel)&#125;/**整段代码中，没有线程创建，没有线程池也没有加锁，仅仅通过关键字 go 实现 goroutine，和通道实现数据交换。编译成exe文件：go build go-test/test3/concurrent.go*/ 4、计算器add.go 123456package simplemath// 加法func Add(a int, b int) int&#123; return a + b&#125; sqrt.go 123456789package simplemathimport &quot;math&quot;// 平方根func Sqrt(i int) int&#123; v := math.Sqrt(float64(i)) return int(v)&#125; main.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package main// 引入其他包import ( &quot;fmt&quot; &quot;go-test/simplemath&quot; &quot;os&quot; &quot;strconv&quot;)// 定义一个用于打印程序使用指南的函数var Usage = func()&#123; fmt.Println(&quot;USAGE：calc command [arguments] ...&quot;) fmt.Println(&quot;\\nThe commands are:\\n\\tadd\\t计算两个数值相加\\n\\tsqrt\\t计算一个非负数的平方根&quot;)&#125;// 程序入口函数func main()&#123; /* * 用于获取命令行参数，注意程序名本身是第一个参数， * 比如 calc add 1 2 这条指令，第一个参数是 calc */ // := 声明并初始化变量，不需要通过 var 声明该变量 args := os.Args // 除程序名本身外，至少需要传入两个其他参数，否则退出 if args == nil || len(args) &lt; 3&#123; Usage() return &#125; // 第二个参数表示计算方法 switch args[1]&#123; // 加法 case &quot;add&quot;: // 至少需要4个参数 if len(args) != 4&#123; fmt.Println(&quot;USAGE: calc add &lt;integer1&gt;&lt;integer2&gt;&quot;) return &#125; // 获取待相加的类型，并将类型转换为整型 v1, err1 := strconv.Atoi(args[2]) v2, err2 := strconv.Atoi(args[3]) // 获取参数出错，则退出 if err1 != nil || err2 != nil&#123; fmt.Println(&quot;USAGE: calc add &lt;integer1&gt;&lt;integer2&gt;&quot;) return &#125; // 从 simplemath 包引入 Add 方法 ret := simplemath.Add(v1, v2) fmt.Println(&quot;Result: &quot;, ret) // 求方根 case &quot;sqrt&quot;: if len(args) != 3&#123; fmt.Println(&quot;USAGE: calc sqrt &lt;integer&gt;&quot;) return &#125; v, err := strconv.Atoi(args[2]) if err != nil&#123; fmt.Println(&quot;USAGE: calc sqrt &lt;integer&gt;&quot;) return &#125; ret := simplemath.Sqrt(v) fmt.Println(&quot;Result: &quot;, ret) default: Usage() &#125;&#125;","categories":[{"name":"Go","slug":"Go","permalink":"http://example.com/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"}],"keywords":[{"name":"Go","slug":"Go","permalink":"http://example.com/categories/Go/"}]},{"title":"Servlet复习","slug":"javaweb1","date":"2021-08-11T11:53:19.000Z","updated":"2021-08-15T05:58:43.269Z","comments":false,"path":"2021/08/11/javaweb1/","link":"","permalink":"http://example.com/2021/08/11/javaweb1/","excerpt":"","text":"Servlet 是什么？ Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势： 性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 Servlet 架构 下图显示了 Servlet 在 Web 应用程序中的位置。 Servlet 任务 Servlet 执行以下主要任务： 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 Servlet 生命周期 Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 init() 方法 init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。 Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。 当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。 init 方法的定义如下： 123public void init() throws ServletException &#123; // 初始化代码... &#125; service() 方法 service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。 每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。 下面是该方法的特征： 123public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException&#123;&#125; service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重载 doGet() 或 doPost() 即可。 doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。 doGet() 方法 GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。 12public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // Servlet 代码 &#125; doPost() 方法 POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。 12public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // Servlet 代码 &#125; destroy() 方法 destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。 在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示： 123public void destroy() &#123; // 终止化代码... &#125; 架构图 下图显示了一个典型的 Servlet 生命周期方案。 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。 Servlet 容器在调用 service() 方法之前加载 Servlet。 然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。 以下为生命周期的一个简单实例： 12345678910111213141516// Servlet 生命周期的三个方法// 1.被创建，执行且只执行一次 init 方法@Overridepublic void init() throws ServletException &#123; super.init(); &#125;// 2.提供服务，执行 service 方法，执行多次 @Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.service(req, resp); &#125;// 3.被销毁，当 Servlet 服务器正常关闭时，执行 destroy 方法，只执行一次@Overridepublic void destroy() &#123; super.destroy(); &#125; Servlet 部署 默认情况下，Servlet 应用程序位于路径 /webapps/ROOT 下，且类文件放在 /webapps/ROOT/WEB-INF/classes 中。 如果您有一个完全合格的类名称 com.myorg.MyServlet，那么这个 Servlet 类必须位于 WEB-INF/classes/com/myorg/MyServlet.class 中。 现在，让我们把 HelloWorld.class 复制到 /webapps/ROOT/WEB-INF/classes 中，并在位于 /webapps/ROOT/WEB-INF/ 的 web.xml 文件中创建以下条目： 12345678&lt;servlet&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 上面的条目要被创建在 web.xml 文件中的标签内。在该文件中可能已经有各种可用的条目，但不要在意。 Servlet和JSP的区别 JSP作为Servlet技术的扩展，经常会有人将JSP和Servlet搞混。本文，将为大家带来servlet和jsp的区别，希望对大家有所帮助。 Servlet和JSP的区别 1、Servlet在Java代码中可以通过HttpServletResponse对象动态输出HTML内容。 2、JSP是在静态HTML内容中嵌入Java代码，然后Java代码在被动态执行后生成HTML内容。 Servlet和JSP各自的特点 1、Servlet虽然能够很好地组织业务逻辑代码，但是在Java源文件中，因为是通过字符串拼接的方式生成动态HTML内容，这样就容易导致代码维护困难、可读性差。 2、JSP虽然规避了Servlet在生成HTML内容方面的劣势，但是在HTML中混入大量、复杂的业务逻辑。 通过MVC双剑合璧 JSP和Servlet都有自身的适用环境，那么有没有什么办法能够让它们发挥各自的优势呢？答案是肯有的，MVC模式就能够完美解决这一问题。 MVC模式，是Model-View-Controller的简称，是软件工程中的一种软件架构模式，分为三个基本部分，分别是：模型（Model）、视图（View）和控制器（Controller）： Controller——负责转发请求，对请求进行处理 View——负责界面显示 Model——业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现 在JSP/Servlet开发的软件系统中，这三个部分的描述如下所示： 1、Web浏览器发送HTTP请求到服务端，然后被Controller(Servlet)获取并进行处理（例如参数解析、请求转发） 2、Controller(Servlet)调用核心业务逻辑——Model部分，获得结果 3、Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容 4、动态生成的HTML内容返回到浏览器显示 MVC模式在Web开发中有很大的优势，它完美规避了JSP与Servlet各自的缺点，让Servlet只负责业务逻辑部分，而不会生成HTML代码；同时JSP中也不会充斥着大量的业务代码，这样能大提高了代码的可读性和可维护性。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://example.com/categories/Java-Web/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"}],"keywords":[{"name":"Java Web","slug":"Java-Web","permalink":"http://example.com/categories/Java-Web/"}]},{"title":"架构学习整理（一）","slug":"architecture1","date":"2021-08-02T14:14:15.000Z","updated":"2021-08-15T06:19:36.883Z","comments":false,"path":"2021/08/02/architecture1/","link":"","permalink":"http://example.com/2021/08/02/architecture1/","excerpt":"","text":"基本概念分布式系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上。 高可用系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性。 集群一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性。 负载均衡请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的。 正向代理和反向代理系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。 架构演进单机架构 以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。浏览器往www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务。 第一次演进：Tomcat与数据库分开部署 Tomcat和数据库分别独占服务器资源，显著提高两者各自性能。随着用户数的增长，并发读写数据库成为瓶颈。 第二次演进：引入本地缓存和分布式缓存 在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcacched作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢。 第三次演进：引入反向代理实现负载均衡 在多台服务器上分别部署Tomcat，使用反向代理软件Nginx把请求均匀分发到每个Tomcat中。此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈。 第四次演进：数据库读写分离 把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能。 第五次演进：数据库按业务分库 把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决。随着用户数的增长，单机的写库会逐渐会达到性能瓶颈 第六次演进：把大表拆分为小表 比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。 这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是MPP（大规模并行处理）架构的一类实现。 目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql、XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等，不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景，这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈。 第七次演进：使用LVS或F5来使多个Nginx负载均衡 由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器，当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同。 第八次演进：通过DNS轮询实现机房间的负载均衡 在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求 第九次演进：引入NoSQL数据库和搜索引擎等技术 当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难。 第十次演进：大应用拆分为小应用 按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级 第十一次演进：复用的功能抽离成微服务 如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过Dubbo、Spring Cloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱。 第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异 通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难。 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理 目前最流行的容器化技术是Docker，最流行的容器管理服务是**Kubernetes(K8S)**，应用/服务可以打包为Dockker镜像，通过K8S来动态分发和部署镜像。Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响，使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低。 第十四次演进：以云平台承载系统 系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用，用户不需要关心应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：IaaS：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；PaaS：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；SaaS：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题。 架构设计总结架构的调整是否必须按照上述演变路径进行？ 不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。 对于将要实施的系统，架构应该设计到什么程度？ 对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。 服务端架构和大数据架构有什么区别？ 所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。 有没有一些架构设计的原则？ N+1设计。系统中的每个组件都应做到没有单点故障； 回滚设计。确保系统可以向前兼容，在系统升级时应能有办法回滚版本； 禁用设计。应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能； 监控设计。在设计阶段就要考虑监控的手段； 多活数据中心设计。若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用； 采用成熟的技术。刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难； 资源隔离设计。应避免单一业务占用全部资源； 架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题； 非核心则购买。非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品； 使用商用硬件。商用硬件能有效降低硬件故障的机率； 快速迭代。系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险； 无状态设计。服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。","categories":[{"name":"架构","slug":"架构","permalink":"http://example.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://example.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"分布式","slug":"分布式","permalink":"http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://example.com/categories/%E6%9E%B6%E6%9E%84/"}]},{"title":"Spring Cloud （一）概述","slug":"springcloud1","date":"2021-07-28T02:21:01.000Z","updated":"2021-08-15T07:03:22.928Z","comments":false,"path":"2021/07/28/springcloud1/","link":"","permalink":"http://example.com/2021/07/28/springcloud1/","excerpt":"","text":"SpringCloud整体架构概览什么是SpringCloud目标协调任何服务，简化分布式系统开发。 简介构建分布式系统不应该是复杂的，SpringCloud对常见的分布式系统模式提供了简单易用的编程模型，帮助开发者构建弹性、可靠、协调的应用程序。SpringCloud是在SpringBoot的基础上构建的，使开发者可以轻松入门并快速提高工作效率。SpringCloud为开发人员提供了快速构建分布式系统架构的工具，例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态等。 整体架构 SpringCloud的版本关系SpringCloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。为了管理SpringCloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个SpringCloud版本对应的子项目版本。为了避免SpringCloud版本号与子项目版本号混淆，SpringCloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本, Brixton是第二个版本。当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第2个SRX版本。 SpringCloud和SpringBoot版本对应关系 SpringCloud Version SpringBoot Version Hoxton 2.2.x Greenwich 2.1.x Finchley 2.0.x Edgware 1.5.x Dalston 1.5.x SpringCloud和各子项目版本对应关系 Component Edgware.SR6 Greenwich.SR2 spring-cloud-bus 1.3.4.RELEASE 2.1.2.RELEASE spring-cloud-commons 1.3.6.RELEASE 2.1.2.RELEASE spring-cloud-config 1.4.7.RELEASE 2.1.3.RELEASE spring-cloud-netflix 1.4.7.RELEASE 2.1.2.RELEASE spring-cloud-security 1.2.4.RELEASE 2.1.3.RELEASE spring-cloud-consul 1.3.6.RELEASE 2.1.2.RELEASE spring-cloud-sleuth 1.3.6.RELEASE 2.1.1.RELEASE spring-cloud-stream Ditmars.SR5 Fishtown.SR3 spring-cloud-zookeeper 1.2.3.RELEASE 2.1.2.RELEASE spring-boot 1.5.21.RELEASE 2.1.5.RELEASE spring-cloud-task 1.2.4.RELEASE 2.1.2.RELEASE spring-cloud-gateway 1.0.3.RELEASE 2.1.2.RELEASE spring-cloud-openfeign 暂无 2.1.2.RELEASE 注意：Greenwich版本是基于SpringBoot 2.1.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护。 SpringCloud子项目简介Spring Cloud Config集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。 Spring Cloud NetflixNetflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。 Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制； Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略； Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力； Feign：基于Ribbon和Hystrix的声明式服务调用组件； Zuul：API网关组件，对请求提供路由及过滤功能。 Spring Cloud Bus用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。 Spring Cloud Consul基于Hashicorp Consul的服务治理组件。 Spring Cloud Security安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。 Spring Cloud SleuthSpringCloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。 Spring Cloud Stream轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。 Spring Cloud Task用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。 Spring Cloud Zookeeper基于Apache Zookeeper的服务治理组件。 Spring Cloud GatewayAPI网关组件，对请求提供路由及过滤功能。 Spring Cloud OpenFeign基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在SpringCloud 2.0中已经取代Feign成为了一等公民。 Spring Cloud Alibaba概述 Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 Github:https://github.com/alibaba/spring-cloud-alibaba SpringCloud Alibaba 组件简介Spring Cloud的几大痛点 部分组件停止维护和更新，有问题也不易解决 部分环境搭建起来比较复杂，没有非常友好的可视化界面 配置相对来说复杂，需要较高的学习成本 Spring Cloud Alibaba的优势 阿里经历过了时间的考验 设计合理 拥有不错的可视化界面，方便运维监控和排查问题 环境搭建和配置简单，学习成本低 SpringCloud Alibaba技术的搭配方案 描述 Spring Cloud Spring Cloud Alibaba 组合选用 服务发现组件 Eureka（停止维护）服务发现组件 Nacos 注册中心 Spring Cloud Alibaba - Nacos 配置中心组件 Spring Cloud Config 配置中心 Nacos 配置中心 Spring Cloud Alibaba - Nacos 断路保护组件 Hystrix 断路保护 Sentinel 服务容错 Spring Cloud Alibaba - Sentinel 链路追踪组件 Sleuth 调用链监控 / Spring Cloud - Sleuth 负载均衡组件 Ribbon / Spring Cloud - Ribbon 远程调用组件 OpenFeign （HTTP+JSON） Dubbo（RPC框架） Spring Cloud - OpenFeign 分布式事务 / Seata 分布式事务 Spring Cloud Alibaba - Seata API 网关 Gateway / Spring Cloud - Gateway Spring Cloud Alibaba版本项目的版本号格式为 x.x.x 的形式，其中 x 的数值类型为数字，从 0 开始取值，且不限于 0~9 这个范围。项目处于孵化器阶段时，第一位版本号固定使用 0，即版本号为 0.x.x 的格式。 由于 Spring Boot 1 和 Spring Boot 2 在 Actuator 模块的接口和注解有很大的变更，且 spring-cloud-commons 从 1.x.x 版本升级到 2.0.0 版本也有较大的变更，因此阿里采取跟 SpringBoot 版本号一致的版本: 1.5.x 版本适用于 Spring Boot 1.5.x 2.0.x 版本适用于 Spring Boot 2.0.x 2.1.x 版本适用于 Spring Boot 2.1.x 2.2.x 版本适用于 Spring Boot 2.2.x Spring Cloud Alibaba 版本和Spring Cloud 和Spring Boot 版本兼容性列表 Spring Cloud 版本 Spring Cloud Alibaba 版本 Spring Boot 版本 Spring Cloud Hoxton.SR3 2.2.x.RELEASE 2.2.x.RELEASE Spring Cloud Greenwich 2.1.x.RELEASE 2.1.x.RELEASE Spring Cloud Finchley 2.0.x.RELEASE 2.0.x.RELEASE Spring Cloud Edgware 1.5.x.RELEASE 1.5.x.RELEASE 我们采用Spring Cloud Hoxton.SR3, Spring Cloud Alibaba 2.2.0.RELEASE, Spring Boot 2.2.6 RELEASE Spring Cloud Alibaba依赖 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Spring Cloud Alibaba 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://example.com/categories/Spring-Cloud/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://example.com/tags/Spring-Cloud/"}],"keywords":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://example.com/categories/Spring-Cloud/"}]},{"title":"计算机网络学习整理","slug":"network1","date":"2021-05-30T09:39:03.000Z","updated":"2021-08-24T09:42:15.693Z","comments":false,"path":"2021/05/30/network1/","link":"","permalink":"http://example.com/2021/05/30/network1/","excerpt":"","text":"计算机网络学习的核心内容就是网络协议的学习。 网络协议 网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。 因为不同用户的数据终端可能采取的字符集是不同的，两者需要进行通信，必须要在一定的标准上进行。一个很形象地比喻就是我们的语言，我们大天朝地广人多，地方性语言也非常丰富，而且方言之间差距巨大。A地区的方言可能B地区的人根本无法接受，所以我们要为全国人名进行沟通建立一个语言标准，这就是我们的普通话的作用。同样，放眼全球，我们与外国友人沟通的标准语言是英语，所以我们才要苦逼的学习英语。 计算机网络协议同我们的语言一样，多种多样。而ARPA公司与1977年到1979年推出了一种名为ARPANET的网络协议受到了广泛的热捧，其中最主要的原因就是它推出了人尽皆知的TCP/IP标准网络协议。目前TCP/IP协议已经成为Internet中的”通用语言”，下图为不同计算机群之间利用TCP/IP进行通信的示意图。 网络层次的划分为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了”开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为： 物理层（Physics Layer） 数据链路层（Data Link Layer） 网络层（Network Layer） 传输层（Transport Layer） 会话层（Session Layer） 表示层（Presentation Layer） 应用层（Application Layer） 其中第四层完成数据传送服务，上面三层面向用户。除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示： OSI七层网络模型TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。 不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。 物理层（Physical Layer）激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。 数据链路层（Data Link Layer）数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。 为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。 数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 有关数据链路层的重要知识点： 数据链路层为网络层提供可靠的数据传输； 基本数据单位为帧； 主要的协议：以太网协议； 两个重要设备名称：网桥和交换机。 网络层网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括： 寻址 路由选择 连接的建立、保持和终止等。 它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果想用尽量少的词来记住网络层，那就是路径选择、路由及逻辑寻址。 网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。 IP协议的主要功能有： 无连接数据报传输 数据报路由选择 差错控制 与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。 网络层的重点为： 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能； 基本数据单位为IP数据报； 包含的主要协议： IP协议（Internet Protocol，因特网互联协议） ICMP协议（Internet Control Message Protocol，因特网控制报文协议） ARP协议（Address Resolution Protocol，地址解析协议） RARP协议（Reverse Address Resolution Protocol，逆地址解析协议） 重要的设备：路由器 传输层（Transport Layer）第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。 重点： 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题 包含的主要协议： TCP协议（Transmission Control Protocol，传输控制协议） UDP协议（User Datagram Protocol，用户数据报协议） 重要设备：网关。 会话层（Session Layer）会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 表示层（Presentation Layer）表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 应用层（Application Layer）为操作系统或网络应用程序提供访问网络服务的接口。 会话层、表示层和应用层重点 数据传输基本单位为报文； 包含的主要协议： FTP（文件传送协议） Telnet（远程登录协议） DNS（域名解析协议） SMTP（邮件传送协议） POP3协议（邮局协议） HTTP协议（Hyper Text Transfer Protocol） IP地址网络地址IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。 广播地址广播地址通常称为直接广播地址，是为了区分受限广播地址。 广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。 组播地址D类地址就是组播地址。 先回忆下A，B，C，D类地址吧： A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255 B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255 C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255 D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信） E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。 注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。 255.255.255.255该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。 注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 0.0.0.0常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。 回环地址127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。 A、B、C类私有地址私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。 A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255 B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255 C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 TCP/IP协议TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。 通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。 IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层–TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。 IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。 TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用”带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为”滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。 TCP报文首部格式 TCP连接建立过程： 首先Client端发送连接请求报文，Server端接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发送ACK报文，并分配资源，这样TCP连接就建立了。 TCP连接断开过程： C-&gt;S，S-&gt;C，C(FIN_WAIT)，C-&gt;S，C(TIME_WAIT)，S未发(证明S关闭)，C关闭 假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请你继续等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络， 怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。”，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了 2MS 后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 为什么要三次握手？ 在只有两次”握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，”三次握手”很有必要！ 为什么要四次挥手？ 试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！ 使用TCP的协议： FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。 UDP协议UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。 UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。 UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。 每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下： 源端口号； 目标端口号； 数据报长度； 校验值。 使用UDP协议包括： TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。 TCP 与 UDP 的区别： TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。 DNS协议DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。 NAT协议NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 DHCP协议DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途： 给内部网络或网络服务供应商自动分配IP地址。 给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 HTTP协议超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。 HTTP 协议包括哪些请求？ GET：请求读取由URL所标志的信息。 POST：给服务器添加信息（如注释）。 PUT：在给定的URL下存储一个文档。 DELETE：删除给定的URL所标志的资源。 HTTP 中， POST 与 GET 的区别 Get是从服务器上获取数据，Post是向服务器传送数据。 Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。Post数据在URL不能看到。 Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。 根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 安全的，意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 幂等，意味着对同一URL的多个请求应该返回同样的结果。 必会在浏览器中输入 http://www.baidu.com/ 后执行的全部过程。现在假设如果我们在（客户端）浏览器中输入 http://www.baidu.com，而 baidu.com 为要访问的服务器，下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作： 1、客户端浏览器通过DNS 解析到www.baidu.com的**IP地址** 为220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3、（网络层）客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4、（链路层）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。","categories":[{"name":"网络","slug":"网络","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C/"}],"keywords":[{"name":"网络","slug":"网络","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C/"}]},{"title":"数据结构基础知识","slug":"csbase1","date":"2021-05-30T08:11:49.000Z","updated":"2021-08-14T02:41:20.551Z","comments":false,"path":"2021/05/30/csbase1/","link":"","permalink":"http://example.com/2021/05/30/csbase1/","excerpt":"","text":"概述数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。不同的数据结构具有各自对应的适用场景，旨在降低各种算法计算的时间与空间复杂度，达到最佳的任务执行效率。 分类线性数据结构（物理结构）数组(Array)、链表(Linked List)、栈(Stack)、队列(Queue) 非线性数据结构（逻辑结构）树(Tree)、堆(Heap)、散列表(Hashing)、图(Graph) 数组数组是将相同类型的元素存储于连续内存空间的数据结构，其长度不可变。 如下图所示，构建此数组需要在初始化时给定长度，并对数组每个索引元素赋值，代码如下： 12345678// 初始化一个长度为 5 的数组 arrayint[] array = new int[5];// 元素赋值array[0] = 2;array[1] = 3;array[2] = 1;array[3] = 0;array[4] = 2; 或者可以使用直接赋值的初始化方式，代码如下： 1int[] array = &#123;2, 3, 1, 0, 2&#125;; 可变数组可变数组是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。 123456789// 初始化可变数组List&lt;Integer&gt; array = new ArrayList&lt;&gt;();// 向尾部添加元素array.add(2);array.add(3);array.add(1);array.add(0);array.add(2); 链表链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。链表的节点对象具有两个成员变量：「值 val」，「后继节点引用 next」。 12345class ListNode &#123; int val; // 节点值 ListNode next; // 后继节点引用 ListNode(int x) &#123; val = x; &#125;&#125; 如下图所示，建立此链表需要实例化每个节点，并构建各节点的引用指向。 12345678// 实例化节点ListNode n1 = new ListNode(4); // 节点 headListNode n2 = new ListNode(5);ListNode n3 = new ListNode(1);// 构建引用指向n1.next = n2;n2.next = n3; 栈栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。 1Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); 如下图所示，通过常用操作 「入栈 push()」,「出栈 pop()」，展示了栈的先入后出特性。 1234stack.push(1); // 元素 1 入栈stack.push(2); // 元素 2 入栈stack.pop(); // 出栈 -&gt; 元素 2stack.pop(); // 出栈 -&gt; 元素 1 注意：通常情况下，不推荐使用 Java 的 Vector 以及其子类 Stack ，而一般将 LinkedList 作为栈来使用。 123456LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;();stack.addLast(1); // 元素 1 入栈stack.addLast(2); // 元素 2 入栈stack.removeLast(); // 出栈 -&gt; 元素 2stack.removeLast(); // 出栈 -&gt; 元素 1 队列队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。 1Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); 如下图所示，通过常用操作 「入队 push()」,「出队 pop()」，展示了队列的先入先出特性。 1234queue.offer(1); // 元素 1 入队queue.offer(2); // 元素 2 入队queue.poll(); // 出队 -&gt; 元素 1queue.poll(); // 出队 -&gt; 元素 2 树树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为 「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。 123456class TreeNode &#123; int val; // 节点值 TreeNode left; // 左子节点 TreeNode right; // 右子节点 TreeNode(int x) &#123; val = x; &#125;&#125; 如下图所示，建立此二叉树需要实例化每个节点，并构建各节点的引用指向。 123456789101112// 初始化节点TreeNode n1 = new TreeNode(3); // 根节点 rootTreeNode n2 = new TreeNode(4);TreeNode n3 = new TreeNode(5);TreeNode n4 = new TreeNode(1);TreeNode n5 = new TreeNode(2);// 构建引用指向n1.left = n2;n1.right = n3;n2.left = n4;n2.right = n5; 图图是一种非线性数据结构，由 「节点（顶点）vertex」 和 「边 edge」 组成，每条边连接一对顶点。根据边的方向有无，图可分为 「有向图」 和 「无向图」 。 如下图所示，此无向图的 顶点 和 边 集合分别为： 顶点集合： vertices = {1, 2, 3, 4, 5} 边集合： edges = {(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)} 表示图的方法通常有两种： 1、邻接矩阵： 使用数组 verticesvertices 存储顶点，邻接矩阵 edgesedges 存储边；edges[i][j] 代表节点 i + 1和节点 j + 1之间是否有边。 123456int[] vertices = &#123;1, 2, 3, 4, 5&#125;;int[][] edges = &#123;&#123;0, 1, 1, 1, 1&#125;, &#123;1, 0, 0, 1, 0&#125;, &#123;1, 0, 0, 0, 1&#125;, &#123;1, 1, 0, 0, 1&#125;, &#123;1, 0, 1, 1, 0&#125;&#125;; 2、邻接表： 使用数组vertices存储顶点，邻接表edges存储边。 edges为一个二维容器，第一维 i 代表顶点索引，第二维 edges[i] 存储此顶点对应的边集和；例如 edges[0] = [1, 2, 3, 4]代表 vertices[0]的边集合为 [1, 2, 3, 4]。 12345678910111213int[] vertices = &#123;1, 2, 3, 4, 5&#125;;List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();List&lt;Integer&gt; edge_1 = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4));List&lt;Integer&gt; edge_2 = new ArrayList&lt;&gt;(Arrays.asList(0, 3));List&lt;Integer&gt; edge_3 = new ArrayList&lt;&gt;(Arrays.asList(0, 4));List&lt;Integer&gt; edge_4 = new ArrayList&lt;&gt;(Arrays.asList(0, 1, 4));List&lt;Integer&gt; edge_5 = new ArrayList&lt;&gt;(Arrays.asList(0, 2, 3));edges.add(edge_1);edges.add(edge_2);edges.add(edge_3);edges.add(edge_4);edges.add(edge_5); 邻接矩阵 VS 邻接表 ： 邻接矩阵的大小只与节点数量有关，即N^2，其中N为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。因此，邻接表 适合存储稀疏图（顶点较多、边较少）；邻接矩阵适合存储稠密图（顶点较少、边较多）。 散列表散列表是一种非线性数据结构，通过利用 Hash 函数将指定的 「键 key」 映射至对应的 「值 value」 ，以实现高效的元素查找。 设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。现需求从「姓名」查找「学号」。 则可通过建立姓名为 key ，学号为 value 的散列表实现此需求，代码如下： 123456789101112// 初始化散列表Map&lt;String, Integer&gt; dic = new HashMap&lt;&gt;();// 添加 key -&gt; value 键值对dic.put(&quot;小力&quot;, 10001);dic.put(&quot;小特&quot;, 10002);dic.put(&quot;小扣&quot;, 10003);// 从姓名查找学号dic.get(&quot;小力&quot;); // -&gt; 10001dic.get(&quot;小特&quot;); // -&gt; 10002dic.get(&quot;小扣&quot;); // -&gt; 10003 自行设计 Hash 函数： 假设需求：从「学号」查找「姓名」。 将三人的姓名存储至以下数组中，则各姓名在数组中的索引分别为 0, 1, 2。 1String[] names = &#123; &quot;小力&quot;, &quot;小特&quot;, &quot;小扣&quot; &#125;; 此时，我们构造一个简单的Hash函数（%为取余符号），公式和封装函数如下所示： hash(key) = (key - 1) % 10000 1234int hash(int id) &#123; int index = (id - 1) % 10000; return index;&#125; 则我们构建了以学号为 key 、姓名对应的数组索引为 value 的散列表。利用此 Hash 函数，则可在 O(1) 时间复杂度下通过学号查找到对应姓名，即： 123names[hash(10001)] // 小力names[hash(10002)] // 小特names[hash(10003)] // 小扣 以上设计只适用于此示例，实际的 Hash 函数需保证低碰撞率、高鲁棒性(健壮性)等，以适用于各类数据和场景。 堆堆是一种基于 「完全二叉树」 的数据结构，可使用数组实现。以堆为原理的排序算法称为 「堆排序」 ，基于堆实现的数据结构为 「优先队列」 。堆分为 「大顶堆」 和 「小顶堆」 ，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。 完全二叉树定义： 设二叉树深度为 k ，若二叉树除第 k 层外的其它各层（第 1 至 k−1 层）的节点达到最大个数，且处于第 k 层的节点都连续集中在最左边，则称此二叉树为完全二叉树。 如下图所示，为包含 1, 4, 2, 6, 8 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式。 通过使用「优先队列」的「压入 push()」和「弹出pop()」操作，即可完成堆排序，实现代码如下： 12345678910111213141516// 初始化小顶堆Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;();// 元素入堆heap.add(1);heap.add(4);heap.add(2);heap.add(6);heap.add(8);// 元素出堆（从小到大）heap.poll(); // -&gt; 1heap.poll(); // -&gt; 2heap.poll(); // -&gt; 4heap.poll(); // -&gt; 6heap.poll(); // -&gt; 8","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"keywords":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"容器技术-Docker入门","slug":"docker1","date":"2021-05-04T15:28:38.000Z","updated":"2021-08-15T05:57:37.081Z","comments":false,"path":"2021/05/04/docker1/","link":"","permalink":"http://example.com/2021/05/04/docker1/","excerpt":"","text":"基础知识镜像image Docker镜像文件（核心文件） 容器container image生成运行的实例 仓库repository 公共仓库 Docker Hub 改为国内镜像（阿里云…） C/S架构基本命令验证安装 docker version docker info 启动docker服务 service docker start systemctl start docker 搜索 docker search [镜像名] image 通过image文件才能生成容器，可以生成同时运行的多个容器 列出所有image文件 docker image ls 删除image文件 docker image rm [imagename] 拉取image文件 docker image pull library/hello-world (library可省略) container image生成容器实例，如果本地仓库没有这个image文件会自动从公共仓库拉取下来 docker container run hello-world 新建容器 docker container start [containerID] 运行已生成并且已停止的容器 容器执行完会自动停止，提供服务的（例如Ubuntu）不会停止 手动终止 docker container kill [containID] 容器生成后就有两个文件分别是image文件和容器文件，关闭容器不会删除容器文件 本机正在运行的容器 docker container ls docker ps 所有容器 docker container ls -all 删除容器 docker container rm [containerID] 容器输出（日志） docker container log [containerID] 进入容器 docker container exec -it [containerID] /bin/bash 需要推广自己的软件，必须要制作image文件 Dockerfile文件 配置image，生成二进制image文件 制作自己的Docker容器 安装实例-it、-itd -i 交互式操作 -t 终端 -d 容器后台运行，默认不会进入容器，需要docker exec 进入 Nginx 下载最新镜像 docker pull nginx:latest 运行容器调整端口并在后台运行 docker run –name nginx-test -p 8089:80 -d nginx 验证 curl 127.0.0.1:8089 Node.js 下载最新镜像 docker pull node:latest 运行 docker run -itd –name node-test node 进入容器验证 docker exec -it node-test /bin/bash node -v MySQL 下载最新镜像 docker pull mysql:latest 运行命名设置端口设置root密码 docker run -itd –name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=19971114abc mysql -p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务 进入mysql容器 docker exec -it mysql-test bash 登录mysql,查看版本 mysql -u root -p19971114abc Tomcat 下载镜像 docker pull tomcat 运行设置端口 测试 Redis 镜像 docker pull redis:latest 运行设置端口 docker run -itd –name redis-test -p 6379:6379 redis 测试 docker exec -it redis-test /bin/bash redis-cil MongoDB 镜像 docker pull mongo:latest 运行设置端口 docker run -itd –name mongo -p 27017:27017 mongo –auth 进入容器 docker exec -it mongo mongo admin 创建一个名为 admin，密码为 123456 的用户。 db.createUser({ user:’admin’,pwd:’123456’,roles:[ { role:’userAdminAnyDatabase’, db: ‘admin’}]}); 尝试使用上面创建的用户信息进行连接。 db.auth(‘admin’, ‘123456’) 微服务思想 软件把任务外包出去，让各种外部服务完成这些任务，软件本身只是底层服务的调度中心和组装层 微服务很适合用 Docker 容器实现，每个容器承载一个服务。一台计算机同时运行多个容器，从而就能很轻松地模拟出复杂的微服务架构。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"}]},{"title":"Java多线程基础","slug":"java2","date":"2021-05-04T04:06:09.000Z","updated":"2021-08-15T06:08:54.394Z","comments":false,"path":"2021/05/04/java2/","link":"","permalink":"http://example.com/2021/05/04/java2/","excerpt":"","text":"基础进程 一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。 一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。 线程的生命周期 新建状态 一个新产生的线程从新状态开始了它的生命周期。它保持这个状态直到程序start这个线程。 就绪状态 当一个线程等待另外一个线程执行一个任务的时候，该线程就进入就绪状态。当另一个线程给就绪状态的线程发送信号时，该线程才重新切换到运行状态。 运行状态 当一个新状态的线程被start以后，线程就变成可运行状态，一个线程在此状态下被认为是开始执行其任务。 阻塞状态(休眠状态) 由于一个线程的时间片用完了，该线程从运行状态进入休眠状态。当时间间隔到期或者等待的事件发生了，该状态的线程切换到运行状态。 死亡状态(终止状态) 一个运行状态的线程完成任务或者其他终止条件发生，该线程就切换到终止状态。 创建线程三种方法 实现Runnable接口(最简单) 继承Thread类本身 方法 start() run() 通过Callable 和 Future 创建线程 常见线程方法 sleep 当前线程暂停 join 加入到当前线程中 setPriority 线程优先级 yield 临时暂停 setDaemon 守护线程 同步问题 多个线程同时修改一个数据的问题 数据变成脏数据 又称为Concurrency（并发）问题 解决问题 synchronized 语句块 当前线程独占对象，直到释放占用 被 synchronized 修饰的，称为线程安全的类 Lock 图 常见线程安全类 Map HashMap 非线程安全 可以存放null HashTable 线程安全 不能存放null 字符串 StringBuilder 非线程安全 单线程速度快 StringBuffer 线程安全 多线程数据安全 List ArrayList 非线程安全 Vector 线程安全 多线程编程 多线程能满足程序员编写非常有效率的程序来达到充分利用CPU的目的，因为CPU的空闲时间能够保持在最低限度。 主要概念 线程同步 互斥同步 一个时间点只允许一个线程访问代码段 条件同步 通过条件变量和三个操作来实现：等待，信号和广播 同步关键字 synchronized 线程死锁 图 线程交互 wait 让占有this的线程等待，并临时释放占有 notify 通知等待this的线程苏醒，可以继续占有 notifyAll() 通知所有等待的线程 线程控制:挂起、停止和恢复 线程池 生产消费模式 对象为一个一个的任务 已创建的线程循环使用 多线程使用 有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。 通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。 请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU花费在上下文的切换的时间将多于执行程序的时间。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"开发必备----Git","slug":"git1","date":"2021-05-04T01:34:55.000Z","updated":"2021-08-15T05:57:30.826Z","comments":false,"path":"2021/05/04/git1/","link":"","permalink":"http://example.com/2021/05/04/git1/","excerpt":"","text":"基础知识版本控制系统 svn 集中式，有一个中央服务器，需要先从上面拉取最新的代码才能干活，干完活再推送上去，必须联网才能工作，对网络要求大 基本概念 repository 源代码仓库 checkout 提取代码 commit 提交代码 update 更新代码 从远程仓库checkout代码 –&gt; 修改 –&gt; update代码（副本可能过期需要更新） –&gt; 调试没问题 –&gt; 提交 –&gt; 大家都可以看见 修改不同代码会合并，修改同一行代码会产生冲突，需手动解决。 让我们假设 Tom 和 Jerry 是一个项目的两个开发者。他们同时从版本库中检出了最新的版本并开始工作。此时，工作副本是与版本库完全同步的。然后，Jerry 很高效的完成了他的工作并提交了更改到版本库中。此时 Tom 的工作副本就过期了。更新操作将会从版本库中拉取 Jerry 的最新改动并将 Tom 的工作副本进行更新。 开发 修改之前更新一次，提交之前再更新一次 先更新，再保留合并后的代码（删除多余的注释和代码），再提交即可解决冲突 取消更改就右边远程版本复制到左边本地版本 git 分布式，没有中央服务器，每个电脑就是一个完整的版本库，相互提交给对方就可看到相互的改动 可以设置自己的分支进行开发并提交，最后需要合并 概念 工作区 自己电脑上看见的目录就是工作区 版本库 仓库的 .git 文件夹就是版本库 暂存区 就在版本库内 自动创建第一个master分支，以及指向master分支的指针HEAD add 添加到暂存区 commit 将暂存区文件提交到当前分支 注意事项 可以监听所有文本文件内容改动，但图像、视频等二进制文件内容改变无法监听，不能知道里面改了什么，只知道大小改变。 Git教程入门 1、新建目录，右键鼠标进入 Git Bash Here 2、git init 将当前目录变成git管理的仓库 3、目录下创建一个文件 4、git add 文件名(可写多个文件名) 添加文件到暂存区 git add xx命令可以将xx文件添加到暂存区，如果有很多文件改动可以通过 git add -A . 来一次添加所有改变的文件。 注意 -A 选项后面还有一个小数点. git add -A表示添加所有内容， git add . 表示添加新文件和编辑过的文件不包括删除的文件; git add -u 表示添加编辑或者删除的文件，不包括新添加的文件 5、git commit -m “注释” 暂存区的文件都提交到仓库 6、git status 文件提交状态 每次git commit后最好查看是否还有未提交 7、修改文件内容 8、git diff 文件名 文件有修改，可查看文件修改了哪些地方 9、git status 查看状态，显示有修改内容，并且未提交 10、 git add 文件名 重复提交步骤 11、git commit -m “注释” 重复提交步骤 12、git status 再次查看状态 13、提交远程仓库 远程仓库 注册GitHub账号 创建密钥与本地关联 创建仓库（名字最好与本地相同） 远程仓库与本地仓库关联 git remote add origin https://github.com/xxx/xxx.git 本地提交到远程仓库，与远程仓库同步 git push -u origin master 提交当前主分支(master) -u 表示本地分支与远程分支同步，远程不用创建新的分支 开发 提交到本地版本库了，执行git push origin master 就可以提交到远程仓库 这就是分布式版本库 注意：以上是先建好本地库，再有远程库流程，工作中一般是直接从远程仓库拉取代码下 多人协作 从远程库克隆 创建好目录，在当前目录下 git bash git clone https://github.com/xxx/xxx.git 查看远程库信息 git remote git remote -v 本地主分支一定要与远程库对应，修复bug分支可以和本地主分支合并后再推送到远程库 多人协作工作模式流程 1、首先，可以试图用 git push origin branch-name （分支名）推送自己的修改. 2、如果推送失败，则因为远程分支比你的本地更新早，需要先用 git pull 试图合并。 3、如果合并有冲突，则需要解决冲突，并在本地提交。再用 git push origin branch-name 推送。 冲突解决 冲突表示：用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; , =======, &gt;&gt;&gt;&gt;&gt;&gt;表示冲突的地方 例如： 123456&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD22222222=======11111111111333333333333&gt;&gt;&gt;&gt;&gt;&gt;&gt; fenzhi1 123&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 主分支上修改的内容======= 分隔符&gt;&gt;&gt;&gt;&gt;&gt;&gt;fenzhi1 分支上修改的内容 解决冲突：修改 fenzhi1 分支内容为主分支上的内容再添加，提交 创建和合并分支 多次提交时间串成一条时间线，就是一个主分支，即master分支，HEAD指向master也就是当前分支，master指向提交 创建分支并切换 查看分支 git branch 带星号就是当前分支 创建分支 git branch dev 创建dev分支 切换分支 git checkout master 切换master分支 创建并切换分支 git checkout -b dev -b 相当于 git branch 提交的分支不同，内容不同 master(当前分支) 合并dev分支 git merge dev 合并后删除dev分支 git branch -d dev 基本命令git init 将当前目录变成git管理的仓库 git clone https://github.com/xxxx/xxxx.git 克隆远程库 git clone -b [branch name] https://github.com/xxxx/xxxx.git 克隆某个分支远程库 git add 文件名 添加文件到暂存区 git add . （小数点） 添加所有新增和有变动文件到暂存区 git commit -m “注释” 提交到仓库 git status 文件提交状态 每次git commit后最好查看是否还有未提交 git remote add origin https://github.com/xxx/xxx.git 与远程仓库关联 git push -u origin master 提交当前主分支 -u 表示本地分支与远程分支同步，远程不用创建新的分支 git push origin [branch name] 提交远程分支仓库 git pull origin master 取回远程主机主分支的更新，再与本地的指定分支合并。 git log git log 查看所有提交的日志，由最近到最远时间 git log –oneline git log –pretty==oneline 简略版日志 git reflog 查看远程库信息 git remote git remote -v git diff 文件名 文件有修改，查看文件修改了哪些地方 版本回退 git reset –hard HEAD^ 回退到上一个版本，^^ 则表示回退到上两个版本 git reset –hard HEAD~5 回退到前 5 个版本 回退到最新版本 git reflog 可显示每次改动提交的版本号 git reset –hard 版本号 git checkout – 文件名 （文件名） 撤销修改（当不用版本回退时可使用） 未添加到暂存区 撤销当前修改内容 已添加到暂存区 撤销未添加到暂存区的内容 – 不能漏，否则变成创建/切换分支 rm 文件名 （文件名） 删除文件 恢复文件 git checkout – 文件名 （文件名） – 不能漏，否则变成创建/切换分支 常用命令清单 http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}]},{"title":"Java基础（复习整理）","slug":"java1","date":"2021-05-03T15:10:09.000Z","updated":"2021-08-14T03:51:52.229Z","comments":true,"path":"2021/05/03/java1/","link":"","permalink":"http://example.com/2021/05/03/java1/","excerpt":"","text":"基础知识和语法Java语言初识 计算机语言发展 机器语言、汇编、C、C++、Java Java的诞生与发展 1995 JavaSE JavaME Android JavaEE 2006(大数据) Hadoop Spark 流式计算 Scala JDK 开发工具包 配置环境变量 JAVA_HOME D:\\JDK8_211 path ;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin CLASSPATH .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 验证安装DOS java -version JRE Java程序运行环境 包含JVM，Java程序运行 跨平台原理 在JVM上运行，无视操作系统 HelloWorld javac Hello.java 生成class文件 java Hello 运行编译好的class文件 编译型和解释型语言 Java是半编译半解释型语言 IDEA 主流开发工具 注释 行内 // 多行 /* */ 文档 /** */ javadoc 命令 生成帮助文档 标识符 关键字 语法规则 大小写敏感 类名首字母大写 方法名小写 源文件名与类名必须相同，后缀名为.java 一个源文件只能有一个public类，可以有多个其他类（内部类、匿名类） 所有程序由主方法入口开始执行 public static void main(String[] args) 标识符 以字母、美元符、下划线开头，不能用数字开头 关键字不能做标识符 数据类型 基本数据类型 整型 byte Byte 8位，1字节 -128(-2^7) ~ 127(2^7-1) short Short 16位，2字节 -32768(-2^15) ~ 32767(2^15-1) int Integer 32位，4字节 -2^31 ~ 2^31-1 整型变量默认为int型 long Long 64位，8字节 -2^63 ~ 2^63 默认值：0L 浮点型 float Float 32位，4字节 默认值：0.0f double Double 64位，8字节 浮点数 金融计算 BigDecimal 字符型 char(Unicode字符) Character 16位，2字节 单引号，‘A’ 字符编码 ASCII UTF-8 Unicode ‘\\u0000’（转义） \\b 退格 \\n 换行 \\r 回车 \\t 制表 &#39; &quot; \\ 布尔型 boolean Boolean 1字节 true/false 默认值：false 引用数据类型 数组 int[] a = {1,2,3,4}; 类（对象） class Hero; 栈指向堆 栈存放对象引用的地址 堆存放对象的信息，栈存放该对象的地址，所以栈指向堆 接口 interface Hero; 默认值：null == 和 equals == 基本类型：比较的是值是否相同 引用类型：比较的是引用是否相同 equals equals 本质上就是 ==，但重写了String和Integer，把引用比较改成了值比较 数据类型转换 自动类型转换 转换原则：从低精度向高精度转换byte-&gt;(short、char)-&gt;int-&gt;long-&gt;float-&gt;double 表数范围小的自动转换为表数范围大的 运算有多种数据类型结果自动转换为最大的数据类型 字符串与任何数据类型相连都会转换为字符串类型 两个char型运算时，自动转换为int型；当char与别的类型运算时，也会先自动转换为int型的，再做其它类型的自动转换 byte和short不能和char相互转换，char值范围为0~65535，byte和short都包含负数 强制类型转换 表数大的转表数小的需要强制转换 运算符为(),括号里写小的数据类型 byte b = (byte)12 装箱和拆箱 装箱：int-&gt;Integer 拆箱：Integer-&gt;int Java包装类的缓存 具体的实现方式为在类中预先创建频繁使用的包装类对象，当需要使用某个包装类的对象时，如果该对象封装的值在缓存的范围内，就返回缓存的对象，否则创建新的对象并返回 哪些包装类没有缓存 float、double 常量 定义 final修饰常量 一般大写命名 final String DEMO = “HELLO”; final 只允许初始化一次 一般与static一起使用 静态不可变 变量 定义 int a = 2; 作用域 类变量 静态变量 必须声明为static类型 局部变量不能被声明为类变量 实例(成员)变量 非静态变量 类之中，方法外，可全局使用 局部变量 方法内，仅限于方法内使用 命名规范 1、见名知意 2、驼峰命名（变量和方法） 3、类，首字母大写，驼峰命名 4、常量，大写+下划线 5、不要使用拼音命令 运算符 算术运算符 +、-、*、/、%、++、– 赋值运算符 = 关系运算符 ‘&gt;’、&lt;、&gt;=、&lt;= 逻辑运算符 &amp;&amp;、||、！ 位运算符 &amp;、|、^、~、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt; 扩展运算符 +=、-=、*=、/= 三目运算符 条件？true的取值:false的取值 优先级 尽量使用 小括号，可读性更好 instanceof 检查当前对象是否是某个特定类型 包机制 域名倒写 package import 为了防治命名冲突 用于放功能相似或相关类 JavaDoc 生成JDK帮助文档 javadoc @author 作者 @Version 版本 @since 最早支持到哪个版本能够使用 @param 参数 @return 返回 @throws 异常 编译文件、生成帮助文档 教程：https://www.bilibili.com/video/BV12J41137hu?p=80 34：11 流程控制 Scanner 用户交互 System.in 顺序结构 程序默认结构，自上而下的执行 选择结构 if 单选择结构 if-else 双选择结构 if-else if-else 多选择结构 switch JDK7支持了String类型 case穿透现象，不加break 就会继续执行下一个case break default 默认，case没有就执行这个 循环结构 while 满足条件后执行 尽量避免死循环 一般不可计次数循环时使用 do…while 至少执行一次，先执行 for for(int i = 0; i &lt; 100; i++) 一般可计次数循环时使用 for-each - for(int num : nums) 增强型for循环 编程：打印九九乘法表 break &amp; continue &amp; return break 跳出循环 continue 终止本次循环，进入下一次循环 return 结束方法的运行 数组 定义 new int[5] 分配好空间 {1,2,3,4} 数组存放的值必须是同一个类型 存储在堆上的对象，可保存多个同类型变量 数组初始化，内存所占空间固定，长度不可改变 静态初始化 int demoArray[3] = {1,2,3}; 动态初始化 int demoArray[10]; 使用 通过下标拿到值 ArrayIndexOutOfBounds 数组下标越界异常 for-each遍历 遍历 数组索引从0开始 for (int i = 0; i &lt; myList.length; i++) {System.out.println(myList[i] + “ “);} for each循环 for (double element: myList) {System.out.println(element);} 二维数组 int[][] Arrays 工具类 方法 排序 sort() sort排序原理 使用了两种排序方法，快速排序和优化的归并排序 快速排序主要是对那些基本类型数据排序，而归并排序用于对Object类型进行排序。 比较 equals() 转为字符串 toString() 排序算法 冒泡排序 选择排序 插入排序 快速排序 归并排序 希尔排序 堆排序 基数排序（桶排序） 笔试：要求手写 面向对象什么是面向对象 一个人就是一个对象，属性：名字，方法：动作 类与对象 类 是Java最小的程序单元 是一个模板，描述对象的状态和行为 是对象的集合 由class定义 对象 Java中除了8个基本数据类型值外，一切都是对象 声明 由类声明 实例化 new创建对象实例化 初始化 创建对象时调用构造方法进行初始化 属性 对象的状态 方法 对象的行为操作 new 对象 栈 存放引用 堆 存放具体对象信息 构造方法 构造的重载 默认无参构造 如果手动定义了有参构造就必须要手动再加一个无参构造 单例模式需要构造器私有，为的就是不让别人去new它，只能创建一个对象 new需要构造方法来创建对象 与类同名，无返回值无void，可以有参数,只能与new结合使用，返回的是类的实例 如果不显式定义构造方法，编译器会为该类隐式提供默认的构造方法 每个类至少一个构造方法（可以有多个），方法名与类名必须相同 方法 语句的集合 定义 修饰符 返回值 方法名(参数名) { return 返回值; } 方法调用 类名.方法 对象.方法 方法重载 名字相同，参数列表不同 命令行传参 给main方法传参 教程：https://www.bilibili.com/video/BV12J41137hu?p=80 45：22 必须掌握，后面JVM调优传参就是这样传，在后面传JVM参数 可变长参数 … 必须放在最后一个参数 递归 自己调用自己，给自己一个出口 时间复杂度高 面试常问 刷leetcode 基础题 封装 属性私有，提供对应get，set 方法 减少耦合 隐藏实现细节 容易理解 继承 关键字 extends super 访问父类成员 super.eat(); this 访问自己 this.eat(); 子类继承父类，继承包括非private修饰的成员变量，方法 减少重复代码，提高代码复用性，提高维护性 不支持多继承，但支持多重继承、不同类继承同一个类 变相多继承 implements 可以实现多个接口 多态 父类的引用指向子类的对象 Person person = new Student(); 引用 person 指向 Student 对象 instanceof 如匹配，可以进行类型之间转换 返回：true / false 同一个行为具有多个不同的表现形式 例子：同一个接口，使用不同实例执行不同的操作 存在的必要条件 继承 重写 父类引用指向子类对象 实现 重写 接口 抽象类 编译时多态通过方法重载 重载只能通过不同的方法参数区分 参数个数不同 参数类型不同 通过指向父类的指针，来调用在不同子类中实现的方法 运行时多态通过方法重写 多态用到了动态绑定 编译时类型与运行时类型不一致就会发生运行时动态绑定（典型的就是重载） Override、Overload 重载 一个类中，两个方法同名，但形参不同（数量，类型不同），返回值可同可不同 重写 方法名，形参和返回值必须相同 子类可以根据自己的需要实现父类的方法 向上转型与向下转型 向上转型：是子类对象由父类引用，格式：parent p = new son 向下转型：是父类向下强制转换到子类对象，前提是该父类对象必须是经过向上转型的对象 对进行过上转型的对象，进行强制下转型Son s = (Son)p; 修饰符 访问修饰符 private 同一个类内 defalt 同一个包内 protected 同一个包内和所有子类 public 所有类 非访问修饰符 static 用来修饰类方法和类变量 静态方法只能用静态变量(static修饰的) final final通常和static一起使用 修饰的类 不能被继承 修饰的方法 不能被重写 修饰的变量 不能被修改 abstract 唯一目的：将来对类进行扩充 用来创建抽象类和抽象方法 类有抽象方法一定要声明为抽象类（抽象类可以没有抽象方法） synchronized 和 volatile 主要用于多线程编程 synchronized修饰的方法只能同一时间只能被一个线程访问 volatile 接口 interface 约束，只能定义方法名 子类实现接口必须重写其中方法 只有一个方法的接口叫做函数式接口，可以使用lambda表达式简化 抽象类 接口比抽象类更抽象，接口不能有实现 抽象类可以有具体的实现 一个类可以实现多个接口 抽象类 abstract 用来创建抽象类和抽象方法 唯一目的：将来对类进行扩充 不能被实例化，必须被继承才能使用，通常在设计阶段决定是否使用 类有抽象方法一定要声明为抽象类（抽象类可以没有抽象方法） 子类继承抽象类，父类有抽象方法子类必须重写抽象方法 抽象类和接口区别 一个类只可以继承一个抽象类，但可以实现多个接口 抽象类可以有构造方法，接口中不能有构造方法 抽象类可以有普通的成员变量，接口中不能有普通的成员变量 抽象类中可以包含静态方法，接口中不能包含静态方法 内部类 定义 将一个类定义在另一个类或方法中 分类 成员内部类 定义在一个类中 局部内部类 定义在一个方法或作用域中 匿名内部类 使用最多 主要编写事件监听代码 lambda 静态内部类 定义在一个类中，static修饰 深入 编译器编译成多个class文件 克隆 浅克隆 浅克隆不会克隆原对象中的引用类型，仅仅拷贝了引用类型的指向 深克隆 深克隆的实现就是在引用类型所在的类实现Cloneable接口，并使用public访问修饰符重写clone方法。 序列化 对象中被 static 或 transient 修饰的变量，在序列化时不被保存 Enum类 为什么构造函数必须是私有的 为了保证每一个枚举类元素的唯一实例，是不会允许外部进行new的 常用APIScanner 键盘输入 Random 生成随机数 Arrays 数组工具类 排序 查找 String 不可变性 final修饰 方法 构造方法 String(char[]) String(byte[],Charset) 字节流，编码 String(StringBuffer) 将StringBuffer转换为String String(StringBuilder) 将StringBuilder转换为String length() 长度 isEmpty() 判空 charAt(int index) 获取指定字符串 getBytes(String charsetName) String变成字节数组 indexOf(int ch) 获取指定下标 subString(int beginIndex) 截取字符串 concat(String str) 包含某个字符串 replace(char oldChar, char newChar) 替换字符串 replaceAll(String, String) 替换全部 split(String, int) 字符串分割成数组 常用 trim() 去掉字符串两边空格 StringBuilder、StringBuffer类 StringBuffer是线程安全的（速度慢，需要同步） StringBuilder不是线程安全的（没有被synchronized（同步）修饰） StringBuffer 可变长 原因：append() 本质：拷贝成新的再返回，还是利用的String 线程安全 synchronized修饰 效率较低 多线程使用 StringBuilder 可变长 原因：append() 本质：拷贝成新的再返回，还是利用的String 单线程下 字符串缓存区大，数据量大使用 数据小使用String 操作量较少 非线程安全 但效率高 原因：不用同步 ArrayList 数组列表 长度可变 类型统一 一般和泛型使用 ArrayList list = ArrayList&lt;&gt;(); Math 数学相关工具类 Date类 时间日期类 当前日期时间 date.toString 格式化日期 SimpleDateFormat ft = new SimpleDateFormat (“yyyy-MM-dd hh:mm:ss”); 正则表达式 用字符串描述的匹配规则 判断年份是否是’20##’ ，通过 String x = “20\\d\\d”; 判断 \\d，表示0~9的数 一般用于数据校验 Object hashcode() toString() clone() getClass() notify() 通知，多线程使用 wait() equals() File 创建文件 查看文件 修改文件 删除文件 包装类 自动装箱与拆箱 八大基本类型不是类，不是面向对象，需要封装成类 异常处理总接口 Throwable Exception 捕获不到需要提升到Throwable，不能捕获Error 自定义异常 继承或实现Exception 接口 运行时异常 1/0 ClassNotFound NullPoint 空指针 UnKnowType 未知类型 下标越界异常 文件类型异常……. 编译会通过，需要手动捕获处理，注意 出现这类异常的时候程序会由虚拟机接管 检查型异常 一般不管，因为编译不会通过 Error AWT 错误 JVM 错误 StackOverFlow 栈溢出 递归会导致错误 OutOfMemory OOM Java内存溢出 一个数字太大，不断创建对象，内存占用满了会导致错误 面试常问 处理 try{} 尝试运行 catch () {} 捕获 先捕获小异常再捕获大异常 finally() 无论是否出现异常，finally中的代码都会被执行 throw 方法内部，手动抛出异常 throws 方法抛出异常","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"技术专家","slug":"knowledge2","date":"2021-04-28T05:46:50.000Z","updated":"2021-08-15T06:33:26.453Z","comments":false,"path":"2021/04/28/knowledge2/","link":"","permalink":"http://example.com/2021/04/28/knowledge2/","excerpt":"","text":"硬实力操作系统、网络编程、数据结构、算法软实力思考力 探因果 寻找一个或多个原因 寻找根本原因 想办法 办法总比困难多 学习力 持续学习 构建知识树，思维导图 鞭策自己工作之余坚持学习 碎片学习、碎片分享 上厕所、坐车、吃饭 几百字都行，只要记录分享 突击学习 问题需要解决，但知识不够，临时突击学习 收获外化 复盘工作思路 总结工具使用技巧 了解技术内部原理 沟通力 沟通 分享","categories":[{"name":"知识体系","slug":"知识体系","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}],"tags":[],"keywords":[{"name":"知识体系","slug":"知识体系","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}]},{"title":"Java后端知识体系","slug":"knowledge1","date":"2021-04-26T05:46:50.000Z","updated":"2021-08-25T01:45:39.334Z","comments":false,"path":"2021/04/26/knowledge1/","link":"","permalink":"http://example.com/2021/04/26/knowledge1/","excerpt":"","text":"纸上得来终觉浅，绝知此事要躬行 看书看的起劲是什么时候，能回想到自己写代码，终于知道为什么要这么写，有种茅塞顿开的感觉，那才叫爽。 基础重点(必须扎实)计算机网络 《计算机网络：自顶向下方法》 HTTP、TCP、IP、ICMP、UDP、DNS、ARP IP地址、MAC地址、OSI七层模型（或者 TCP/IP 五层模型） HTTPS安全相关的：数字签名、数字证书、TLS 常见网络攻击：局域网ARP泛洪、DDoS、TCP SYN Flood、XSS等 TCP协议（最重要） TCP协议 三次握手、四次挥手 状态转换 TCP状态中TIME_WAIT 拥塞控制 快速重传、慢启动 问题 TCP 如何实现可靠传输的（画外音：如何基于 UDP 实现可靠传输） TCP 连接建立为什么不是两次握手（画外音：三次握手的充分必要性说明） TIME_WAIT 的存在解决了什么问题，等待时间为什么是 2 MSL 核心 可靠传输 + 高效传输（流量控制和窗口管理） HTTP、HTTPS 从 URL 输入到页面展现到底发生什么 学习方法 学习抓住一条主线 一个数据包是如何发送出去的 带着问题去思考为什么这么做 操作系统 《现代操作系统》 进程管理 并发、同步互斥、锁 内存管理 文件系统 重点 OS四大模块的理论知识 进程与线程管理 内存管理 IO与文件系统 设备管理 了解Linux内核部分实现原理 内存管理 进程管理 虚拟文件系统 与编程最密切 内存 进程 IO 认知 操作系统由哪些构成 进程的状态、切换、调度 进程间通信方式（共享内存、管道、消息） 进程和线程的区别 线程的实现方式（一对一、多对一等） 互斥与同步（信号量、管程、锁） 死锁检测与避免 并发经典的问题：读者写者、哲学家就餐问题 为什么需要虚拟内存，MMU 具体如何做地址转换的 内存为什么分段、分页 页面置换算法 文件系统是如何组织的 虚拟文件系统（VFS）是如何抽象的 。。。。 数据结构与算法 《漫画算法》、《算法》 数据结构 字符串 数组 链表 栈 队列 二叉树 堆 哈希 算法 十大排序 查找、二分 贪心 分治 动态规划 回溯 设计模式 《重学Java设计模式》 单例 工厂 代理 策略 模板方法 观察者 适配器 责任链 建造者 。。。。 Java语言 语言基础 《Java核心技术》 基础语法 面向对象 常用API 异常处理 集合 IO 多线程 网络编程 泛型 反射 注解 JVM 《深入理解Java虚拟机》 类加载机制 双亲委托 字节码执行机制 JVM内存模型 堆区 虚拟机栈 方法区 GC垃圾回收 JVM性能监控与故障定位 JVM调优 多线程、锁、并发 1:《Java并发编程的艺术》、2:《Java并发编程实战》 并发编程基础 线程池 锁 乐观锁、悲观锁 互斥锁、共享锁 可重入锁、偏向锁 轻量级锁、CAS与自旋锁 并发容器 原子类 JUC并发工具类 网络编程 学习路径 Socket API + 多线程 + 网络模型/IO模型 + IO复用 Netty 核心点 进程间通信方式：信号量、管道、共享内存、socket 等 多线程编程：互斥锁、条件变量、读写锁、线程池等 五大 IO 模型：同步、异步、阻塞、非阻塞、信号驱动 高性能 IO 两种模式：Reactor 和 Proactor IO 复用机制：epoll、select、poll（破解 C10K 问题的利器） Java源码 数据库/SQL 《SQL必知必会》、《高性能MySQL》 SQL语句 手写SQL 联表 聚合 SQL语句优化 事务、隔离级别 索引 锁 应用框架后端 JSP、Servlet Spring家族 Spring IOC AOP Spring MVC MyBatis SSM 打war包 Tomcat运行 Spring Boot 打jar包 内嵌Tomcat 微服务架构 知识点 自动配置、开箱即用 整合Web 整合数据库（事务问题） 整合权限 Shiro SpringSecurity 各种中间件 缓存 MQ RPC框架 Dubbo NIO框架 Netty Spring Cloud Netflix Eureka 服务治理组件，包括服务端的注册中心和客户端的服务发现机制。 Ribbon 负载均衡的服务调用组件，具有多种负载均衡调用策略。 Hystrix 服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力。 Feign 基于Ribbon和Hystrix的声明式服务调用组件。 Zuul API 网关服务，过滤、安全、监控、限流、路由。 Alibaba Nacos 阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Sentinel 面向分布式服务架构的轻量级流量控制产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 RocketMQ 一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo Apache Dubbo 是一款高性能 Java RPC 框架，用于实现服务通信。 Seata 阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Config 分布式配置中心。配置管理工具，支持使用 Git 存储配置内容，支持应用配置的外部化存储，支持客户端配置信息刷新、加解密配置内容等。 Bus 事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。 Consul 服务注册和配置管理中心。 Security 安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。 Sleuth SpringCloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。 Stream 轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。 Task 用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。 Zookeeper 服务注册中心。 Gateway（可替代 Zuul） Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方式。Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。 OpenFeign（可替代 Feign） OpenFeign 是 Spring Cloud 在 Feign 的基础上支持了 Spring MVC 的注解，如 @RequesMapping等等。OpenFeign 的 @FeignClient 可以解析 SpringMVC 的 @RequestMapping 注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。 项目经验 总结 中间件 缓存 Redis 5大数据类型 事务 消息通知 管道 持久化 集群 消息 RabbitMQ RocketMQ Kafka 搜索 ElasticSearch 前端 基础套餐 三大件 HTML CSS JavaScript 基础库 jQuery Ajax 模板框架 JSP Thymeleaf FreeMaker 组件化框架 Node VUE React Angular 开发工具集成开发环境 Eclipse IDEA VSCode Linux系统 Linux常用命令 基本Shell脚本 代码管理工具 Git Git命令和使用 SVN 项目管理/构建工具 Maven Gradle 应用运维Web服务器 Nginx 应用服务器 Tomcat 容器技术 Docker Kubernetes(K8S) 管理运维容器 持续集成、持续发布 Jenkins 代码质量检测 Sonar 日志收集、分析 ELK CDN加速","categories":[{"name":"知识体系","slug":"知识体系","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"知识体系","slug":"知识体系","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}],"keywords":[{"name":"知识体系","slug":"知识体系","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}]},{"title":"设计模式学习记录（一）代理模式","slug":"designpattern1","date":"2021-04-11T15:10:58.000Z","updated":"2021-08-14T03:28:37.588Z","comments":false,"path":"2021/04/11/designpattern1/","link":"","permalink":"http://example.com/2021/04/11/designpattern1/","excerpt":"","text":"前言为什么要学设计模式？？工作一年多了，也写了一年多的业务代码，if else 用的炉火纯青，一个 if else 不行就两个 else if 哈哈，然后就变成了一坨。。，这谁顶得住啊，不行，写代码一定要优雅~~，在合适的场景使用合适的设计模式，重用代码、让代码更容易被他人理解、保证代码可靠性。 代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 1、创建一个接口123456789101112package com.fengx.design_patterns.proxy_pattern;/** * @author: Fengx * @create: 2021-06-24 * @description: 1、创建一个接口 **/public interface Image &#123; void display();&#125; 2、创建实现接口的实体类12345678910111213141516171819202122232425package com.fengx.design_patterns.proxy_pattern;/** * @author: Fengx * @create: 2021-06-24 * @description: 2、创建实现接口的实体类 **/public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display()&#123; System.out.println(&quot;展示：&quot; + fileName); &#125; private void loadFromDisk(String fileName)&#123; System.out.println(&quot;第一次从加载对象 &quot; + fileName); &#125;&#125; 3、创建Image的代理类12345678910111213141516171819202122232425package com.fengx.design_patterns.proxy_pattern;/** * @author: Fengx * @create: 2021-07-05 * @description: 3、创建Image的代理类 **/public class ProxyImage implements Image&#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display()&#123; // 当被请求时，使用 ProxyImage 来获取 RealImage 类的对象 if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125; 4、当被请求时，使用 ProxyImage 来获取 RealImage 类的对象1234567891011public class ProxyPatternDemo &#123; public static void main(String[] args) &#123; Image image = new ProxyImage(&quot;fengx.jpg&quot;); // 图像第一次需要从磁盘加载 image.display(); System.out.println(&quot;&quot;); // 图像不需要从磁盘加载 image.display(); &#125;&#125; 输出结果1234第一次从加载对象 fengx.jpg展示：fengx.jpg展示：fengx.jpg","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"LeetCode-2.两数相加","slug":"leetcode2","date":"2021-03-29T09:08:16.000Z","updated":"2021-08-24T09:19:53.983Z","comments":false,"path":"2021/03/29/leetcode2/","link":"","permalink":"http://example.com/2021/03/29/leetcode2/","excerpt":"","text":"标签：递归、链表、数学 题目给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0开头。 示例 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package leetcode;/** * 2、两数相加 * 标签：递归、链表、数学 * @author Fengx * @date 2021/3/25 0025 */public class Solution2 &#123; public static ListNode addTwoNumbers(ListNode l1, ListNode l2)&#123; // 根节点 ListNode root = new ListNode(0); // 答案链表(表示和的链表)根节点 ListNode cursor = root; // 进位值 int carry = 0; // 遍历两个链表 while(l1 != null || l2 != null ||carry != 0)&#123; // l1节点赋值 int l1Val = l1 != null ? l1.val : 0; // l2节点赋值 int l2Val = l2 != null ? l2.val : 0; // 两个链表同一个位置数字和当前位置进位值相加(这个进位值是上一个位置两个链表数字相加除以10的值) int sumVal = l1Val + l2Val + carry; // 答案链表处相应位置的节点数字 ListNode sumNode = new ListNode(sumVal % 10); // 新的进位值 carry = sumVal / 10; // 答案链表下一个节点数字 cursor.next = sumNode; // 答案链表当前位置数字 cursor = sumNode; // 到下一个位置计算 if(l1 != null)&#123; l1 = l1.next; &#125; if(l2 != null)&#123; l2 = l2.next; &#125; &#125; return root; &#125; /** * 自定义单向链表 */ static class ListNode&#123; int val; ListNode next; ListNode(int val)&#123; this.val = val; &#125; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"数据结构与算法/LeetCode","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}],"keywords":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"数据结构与算法/LeetCode","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/"}]},{"title":"LeetCode-1.两数之和","slug":"leetcode1","date":"2021-03-26T02:28:47.000Z","updated":"2021-08-24T09:00:05.646Z","comments":false,"path":"2021/03/26/leetcode1/","link":"","permalink":"http://example.com/2021/03/26/leetcode1/","excerpt":"","text":"标签：数组、链表 题目给定一个整数数组nums和一个整数目标值 target，请你在该数组中找出和为目标值 的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]。 代码123456789101112131415161718192021222324252627282930313233package leetcode;import java.util.Arrays;import java.util.HashMap;import java.util.Map;/** * 1、两数之和 * @author Fengx * @date 2021/3/24 0024 */public class Solution1 &#123; public static int[] twoSum(int[] nums, int target)&#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // 遍历数组 for(int i = 0; i &lt; nums.length; i++)&#123; // 判断map的key里有没有target减去数组的一个值的差在不在map里，在的话说明数组中存在两个数之和等于target if(map.containsKey(target - nums[i]))&#123; // 返回这个差的下标 和 减数的下标 return new int[] &#123;map.get(target - nums[i]),i&#125;; &#125; // 每次循环存数组的一个值和这个值的下标 map.put(nums[i],i); &#125; throw new IllegalArgumentException(&quot;No Two Sum Solution&quot;); &#125; public static void main(String[] args) &#123; int[] nums = &#123;1,4,5,6&#125;; int target = 10; System.out.println(Arrays.toString(twoSum(nums, target))); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"数据结构与算法/LeetCode","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}],"keywords":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"数据结构与算法/LeetCode","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/"}]},{"title":"开发必备----Linux","slug":"linux1","date":"2021-01-28T02:04:25.000Z","updated":"2021-08-14T03:37:30.388Z","comments":false,"path":"2021/01/28/linux1/","link":"","permalink":"http://example.com/2021/01/28/linux1/","excerpt":"","text":"Linux系统目录1234567891011121314/ -- 根目录├── bin -- 大部分系统命令├── sbin -- 超级用户才能执行的命令目录├── boot -- 系统启动相关目录├── dev -- 设备文件目录├── etc -- 配置文件目录├── home -- 普通用户的目录（一个用户对应一个文件夹）├── lib 、lib64 -- 库文件、64位库文件├── lost+found -- 系统异常时临时保存的数据，用于恢复等操作├── media -- 媒体目录├── mnt -- 挂载目录，通用挂载点├── opt -- 安装系统非必需的软件的目录（应用软件安装目录）├── root -- root用户的家目录└── usr -- 存放用户安装的应用程序 系统服务管理systemctl systemctl命令是service和chkconfig命令的组合体，可用于管理系统。 输出系统中各个服务的状态 1systemctl list-units --type=service 查看服务的运行状态 1systemctl status firewalld 关闭服务 1systemctl stop firewalld 启动服务 1systemctl start firewalld 重新启动服务（不管当前服务是启动还是关闭） 1systemctl restart firewalld 重新载入配置信息而不中断服务 1systemctl reload firewalld 禁止服务开机自启动 1systemctl disable firewalld 设置服务开机自启动 1systemctl enable firewalld 文件管理ls列出指定目录下的所有文件，列出/目录下的文件 1ls -l / pwd获取目前所在工作目录的绝对路径 1pwd cd改变当前工作目录 1cd /usr/local date显示或修改系统时间与日期 1date &#x27;+%Y-%m-%d %H:%M:%S&#x27; passwd用于设置用户密码 1passwd root su改变用户身份（切换到超级用户） 1su clear用于清除屏幕信息 1clear man显示指定命令的帮助信息 1man ls who显示目前登录到系统的用户 1who -buT free显示系统内存状态（单位MB） 1free -m ps显示系统进程运行动态 1ps -ef 端口查看所有应用占用端口情况 1netstat -ap 查找8080端口是否被占用 1netstat -ap |grep 8080 进程查看所有进程 1ps -ef 查看tomcat进程 1ps -ef |grep tomcat （输出如下 *** 5144 。。。等等.Bootstrap start 说明tomcat已经正常启动， 5144 就为进程号 pid = 5144） 查看监听进程号 1netstat -anp|grep pid 杀死进程 1kill -9 5144 查看sshd进程的运行动态 1ps -ef | grep sshd top查看即时活跃的进程，类似Windows的任务管理器 1top mkdir创建目录 1mkdir /usr/newdir more用于分页查看文件，例如每页10行查看boot.log文件 1more -c -10 /var/log/boot.log cat用于查看文件，例如查看Linux启动日志文件文件，并标明行号 1cat -Ab /var/log/boot.log touch用于创建文件，例如创建text.txt文件 1touch text.txt rm删除文件 1rm text.txt 强制删除某个目录及其子目录 1rm -rf testdir/ cp用于拷贝文件，例如将test1目录复制到test2目录 1cp -r /mydata/tes1 /mydata/test2 mv用于移动或覆盖文件 1mv text.txt text2.txt 压缩与解压tar将/etc文件夹中的文件归档到文件etc.tar（并不会进行压缩） 1tar -cvf /mydata/etc.tar /etc 用gzip压缩文件夹/etc中的文件到文件etc.tar.gz 1tar -zcvf /mydata/etc.tar.gz /etc 用bzip2压缩文件夹/etc到文件/etc.tar.bz2 1tar -jcvf /mydata/etc.tar.bz2 /etc 分页查看压缩包中内容（gzip） 1tar -ztvf /mydata/etc.tar.gz |more -c -10 解压文件到当前目录（gzip） 1tar -zxvf /mydata/etc.tar.gz 解压文件到指定目录（gzip） 1tar -zxvf /mydata/etc.tar.gz -C /mydata/etc 终端编辑器vi/vim(需要安装) 1yum install -y vim 打开/创建文件 1vim hello.txt 编辑模式 按任意键开始编辑 正常模式 esc 保存、退出 shift + : w–保存q–退出wq–保存并退出q!–强制退出set nu–显示行号set nonu–隐藏行号 注意若非正常关闭vim，则会生成临时文件（隐藏的），需要删除 磁盘和网络管理df查看磁盘空间占用情 1df -hT du查看当前目录下的文件及文件夹所占大小 1du -h --max-depth=1 ./* ifconfig显示当前网络接口状态 1ifconfig netstat查看当前路由信息 1netstat -rn 查看所有有效TCP连接 1netstat -an 查看系统中启动的监听服务 1netstat -tulnp 查看处于连接状态的系统资源信息 1netstat -atunp wget从网络上下载文件 文件上传下载安装上传下载工具lrzsz 1yum install -y lrzsz 上传文件，输入以下命令XShell会弹出文件上传框 1rz 下载文件，输入以下命令XShell会弹出文件保存框 1sz fileName 软件的安装与管理rpm RPM是Red-Hat Package Manager的缩写，一种Linux下通用的软件包管理方式，可用于安装和管理.rpm结尾的软件包。 安装软件包 1rpm -ivh nginx-1.12.2-2.el7.x86_64.rpm 模糊搜索软件包 1rpm -qa | grep nginx 精确查找软件包 1rpm -qa nginx 查询软件包的安装路径 1rpm -ql nginx-1.12.2-2.el7.x86_64 查看软件包的概要信息 1rpm -qi nginx-1.12.2-2.el7.x86_64 验证软件包内容和安装文件是否一致 1rpm -V nginx-1.12.2-2.el7.x86_64 更新软件包 1rpm -Uvh nginx-1.12.2-2.el7.x86_64 删除软件包 1rpm -e nginx-1.12.2-2.el7.x86_64 yum Yum是Yellow dog Updater, Modified的缩写，能够在线自动下载RPM包并安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，非常方便！ 安装软件包 1yum install nginx 检查可以更新的软件包 1yum check-update 更新指定的软件包 1yum update nginx 在资源库中查找软件包信息 1yum info nginx* 列出已经安装的所有软件包 1yum info installed 列出软件包名称 1yum list nginx* 模糊搜索软件包 1yum search nginx","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"keywords":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}]},{"title":"MySQL建表规约整理-《Java开发手册》","slug":"database1","date":"2021-01-24T06:29:21.000Z","updated":"2021-08-13T15:42:55.819Z","comments":false,"path":"2021/01/24/database1/","link":"","permalink":"http://example.com/2021/01/24/database1/","excerpt":"","text":"建库1、库名与应用名称尽量一致 建表1、表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明：MySQL 在 Windows下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例：aliyun_admin，rdc_config，level3_name 反例：AliyunAdmin，rdcConfig，level_3_name 2、表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。 3、表的命名最好是遵循“业务名称_表的作用”。 正例：alipay_task / force_project / trade_config 建字段 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 1、数据表必备三字段：id, create_time, update_time。 说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time, update_time的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。 是与否类型字段1、表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。 说明：任何字段如果为非负数，必须是unsigned。 注意：POJO类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在设置从 is_xxx 到Xxx的映射关系。数据库表示是与否的值，使用 tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围。 正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 普通字段1、禁用保留字，如desc、range、match、delayed 等，请参考 MySQL 官方保留字。 2、如果存储的字符串长度几乎相等，使用char 定长字符串类型。 索引字段1、主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。 说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称 数字字段1、小数类型为 decimal，禁止使用 float 和 double。 说明：在存储的时候，float 和 double都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。 长字段1、varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 改字段1、如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 冗余字段1、字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循 不是频繁修改的字段。 不是唯一索引的字段。 不是 varchar 超长字段，更不能是text字段。 正例：各业务线经常冗余存储商品名称，避免查询时需要调用 IC 服务获取 分库分表1、单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"开发必备----SQL","slug":"database2","date":"2020-12-01T03:08:20.000Z","updated":"2021-08-15T05:57:51.897Z","comments":false,"path":"2020/12/01/database2/","link":"","permalink":"http://example.com/2020/12/01/database2/","excerpt":"","text":"前言唉，说是Java开发，其实写的最多的还是SQL，搞得我有点迷啊，我这是SQL工程师吧。。。。不说了，还是写一篇备忘录吧，一方面巩固，一方面方便自己查询，没有的就查漏补缺，后面可能会根据不同数据库，场景，性能来添油加醋。。。 说明一下这个SQL备忘录主要使用于MySQL，其他数据库可能略有不同，后面会总结一下。。。 DDL（数据定义语言）创建新数据库1CREATE DATABASE [数据库名] 删除数据库1DROP DATABASE [数据库名] 同理，创建和删除表一样写法，DATABASE 改成 TABLE 创建索引1CREATE INDEX [索引名] ON [表名] 删除索引1DROP INDEX [索引名] DML（数据操作语言）insert（插入）单条插入1insert into students (class_id,name,gender,score) values (2,&#x27;大牛&#x27;,&#x27;M&#x27;,80); 多条插入123insert into students (class_id,name,gender,score) values (2,&#x27;大牛&#x27;,&#x27;M&#x27;,80),(3,&#x27;小牛&#x27;,&#x27;S&#x27;,30); delete（删除）单条1delete from students where id = 1; 多条1delete from students where id &gt;= 5 and id &lt;= 7; 更新（update）单条1update students set name = &#x27;大牛&#x27;,score = 66 where id = 1; 多条1update students set name = &#x27;小牛&#x27;,score = 77 where id &gt;= 5 and id &lt;= 10; 使用表达式1update students set score = score + 10 where id &lt;= 20; 咳咳，很快啊，重点来了 查询（select）select常见完整语句1select [目标列名] from [数据表名][where 行条件表达式][group by [列名]][having [组表达式]][order by [列名] [asc/desc]] 经典查询查询所有1select * from students; 实际项目中尽量不要使用，影响性能 查询单行、多行1select name,class_id from students where id = 10; 1select name,class_id from students where id &gt; 10 and id &lt; 20; 投影查询 让结果集仅包含指定列SELECT 列1, 列2, 列3 FROM …例子： 1SELECT id, score, name FROM students; 起别名SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM …;可以给每一列起个别名，结果集的列名可以与原表的列名不同例子： 1SELECT id stu_id, score points, name stu_name FROM students; WHERE 1SELECT id, score points, name FROM students WHERE gender = &#x27;M&#x27;; 排序 ORDER BY ASC升序1SELECT id, name, gender, score FROM students ORDER BY score; 默认的排序规则是ASC：“升序”，即从小到大，ASC可以省略，即 ORDER BY score ASC = ORDER BY score DECS降序1SELECT id, name, gender, score FROM students ORDER BY score DESC; 多排序 当score列有相同的数据，要进一步排序，可以继续添加列名，例如使用ORDER BY score DESC, gender表示先按score列倒序，如果有相同分数的，再按gender列排序： 1SELECT id, name, gender, score FROM students ORDER BY score DESC, gender; WHERE如果有WHERE子句，ORDER BY子句要放到WHERE子句后面,先查出来在排序 1SELECT id, name, gender, scoreFROM studentsWHERE class_id = 1ORDER BY score DESC; 分页查询 LIMIT OFFSET 或 LIMIT N,M （例：limit 0,20：第0条记录开始，拿20条数据） 实现：要实现分页功能，实际上就是从结果集中显示第1到100条记录作为第1页，显示第101到200条记录作为第2页，以此类推。先进行排序： 1SELECT id, name, gender, score FROM students ORDER BY score DESC; 现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用LIMIT 3 OFFSET 0： 1SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0; 上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3： 1SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 3; LIMIT 3表示的意思是“最多3条记录”。 OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。 使用LIMIT OFFSET 分页时，随着N越来越大，查询效率也会越来越低。 聚合查询1SELECT COUNT(*) FROM students; COUNT((星号))表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT((星号))。 通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果： 1SELECT COUNT(*) num FROM students; WHERE 1SELECT COUNT(*) boys FROM students WHERE gender = &#x27;M&#x27;; 除了COUNT()函数外，SQL还提供了如下聚合函数： 1函数 说明SUM 计算某一列的合计值，该列必须为数值类型AVG 计算某一列的平均值，该列必须为数值类型MAX 计算某一列的最大值MIN 计算某一列的最小值 MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 1SELECT AVG(score) average FROM students WHERE gender = &#x27;M&#x27;; 如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL： 分组聚合 GROUP BY 1SELECT COUNT(*) num FROM students GROUP BY class_id; 执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中： 1SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; 也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数： 1SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender; 上述查询结果集一共有6条记录，分别对应各班级的男生和女生人数。 多表查询查询多张表1SELECT * FROM students, classes; students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。 这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。 正确用法 1SELECT students.id sid, students.name, students.gender, students.score, classes.id cid, classes.name cnameFROM students, classes; 表允许设置别名 1SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes c; WHERE 1SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes cWHERE s.gender = &#x27;M&#x27; AND c.id = 1; 连接查询 连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。 1SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s; 上面的结果集只有class_id列，缺少对应班级的name列。最常用的一种内连接——INNER JOIN来实现：（内连接） 1SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sINNER JOIN classes cON s.class_id = c.id; INNER JOIN查询的写法是： 1先确定主表，仍然使用FROM &lt;表1&gt;的语法；再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接；可选：加上WHERE子句、ORDER BY等子句。 使用别名不是必须的，但可以更好地简化查询语句。 函数总数1select count as totalcount from table1 求和1select sum(field1) as sumvalue from table1 平均1select avg(field1) as avgvalue from table1 最大1select max(field1) as maxvalue from table1 最小1select min(field1) as minvalue from table1 高级查询运算词UNION 运算符UNION 运算符通过组合其他两个结果表（例如 TABLE1 和TABLE2）并消去表中任何重复行而派生出一个结果表。 当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。 两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 EXCEPT 运算符EXCEPT运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。 当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 INTERSECT 运算符INTERSECT运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。 当 ALL随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 使用外连接left（outer）join左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。 1select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c right（outer）join右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 full/cross（outer）join全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。 分组Group by一张表，一旦分组 完成后，查询后只能得到组相关的信息。 组相关的信息：（统计信息） count,sum,max,min,avg 分组的标准) 在select统计函数中的字段，不能和普通的字段放在一起。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Nginx--Linux上搭建静态资源服务器","slug":"nginx1","date":"2020-09-15T03:59:51.000Z","updated":"2021-08-15T06:41:44.654Z","comments":false,"path":"2020/09/15/nginx1/","link":"","permalink":"http://example.com/2020/09/15/nginx1/","excerpt":"","text":"搭建服务器原因前后端分离已成为互联网项目开发的业界标准使用方式，通过nginx+tomcat的方式（也可以中间加一个nodejs）有效的进行解耦，并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。这个步骤是系统架构从猿进化成人的必经之路。核心思想是前端html页面通过ajax调用后端的restuful api接口并使用json数据进行交互。在互联网架构中：Web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。一般都是只有web服务器才能被外网访问，应用服务器只能内网访问。 简介Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。它最常的用途是提供反向代理服务。 开始搭建Linux下安装Node.js环境下载nodejs程序包网址：https://nodejs.org/en/download/ 把程序包上传到服务器例如放在home文件夹 进入所在目录，解压1tar -xvf node-v6.11.2-linux-x64.tar.xz 重命名文件夹1mv node-v6.11.2-linux-x64 nodejs 建立软链接，配置全局环境变量（根据自己的目录）12ln -s /opt/nodejs/bin/npm /usr/local/bin/ln -s /opt/nodejs/bin/node /usr/local/bin/ 检查是否配置成功12node -vnpm -v 建议 通过cnpm命令安装包都会通过淘宝镜像NPM下载，速度会更快。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 这里同样需要安装软连接：（文件名自己改） 1ln -s /root/node-v8.9.3-linux-x64/bin/cnpm /usr/local/bin/cnpm 到此安装完成。 启动node推荐使用pm2启动，不然服务器断了连接服务就停止了，常规安装方式 1cnpm i pm2 -g 同样需要建立软连接： 1ln -s /root/node-v8.9.3-linux-x64/bin/pm2 /usr/local/bin/pm2 pm2的使用可以参考官网 http://pm2.keymetrics.io/ 安装Nginx准备工作Nginx的安装依赖于以下三个包，在安装Nginx之前首先必须安装一下的三个包，注意安装顺序如下： SSL功能需要openssl库，直接通过yum安装: yum install opensslgzip模块需要zlib库，直接通过yum安装: yum install zlibrewrite模块需要pcre库，直接通过yum安装: yum install pcre 安装Nginx依赖项和Nginx使用yum安装nginx需要包括Nginx的库，安装Nginx的库 1#rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 使用下面命令安装nginx 1yum install nginx 启动Nginx 1service nginx start 停止 1service nginx stop 重启 1service nginx restart 浏览器访问localhost就会出现Nginx的欢迎界面表示你安装成功了，否则就是安装失败了 配置Nginx CentOS安装Nginx后，安装在了 /etc/nginx/目录下，你可以打开/etc/nginx/conf.d/default.conf查看里面的配置，包括监听端口，域名和nginx访问的根目录 进入nginx安装目录的conf.d目录下，修改default.conf文件，在一个server{}中添加 一个location 部分配置代码如下： 12345678910111213server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; location /image/ &#123; root /usr/local/myImage/; autoindex on; //资源目录展开 &#125;&#125; 从上面的配置可以看出来 端口为80，server_name为localhost（写ip地址也可以） 1234location /image/ &#123; root /usr/local/myImage/; autoindex on;&#125; 这个配置表示输入 localhost:80/image/ 时会访问本机的/usr/local/myImage/image/ 目录，所以在新建/usr/local/myImage/image/目录，同时还要在nginx安装目录的html目录中新建一个与location中image同名的image目录，虽然该目录里面什么也没有，在/usr/local/myImage/image/中我们放一张图片1.jpg上去，重启nginx服务，就可以通过localhost:80/image/1.jpg访问了 12root@ubuntu:/usr/local/nginx/html# mkdir imageroot@ubuntu:/usr/local/nginx/html# mkdir /usr/local/myImage/image 放一张照片上去 123root@ubuntu:/usr/local/nginx/html# cd /usr/local/myImage/imageroot@ubuntu:/usr/local/myImage/image# ls 1.jpgroot@ubuntu:/usr/local/myImage/image# 重启nginx效果","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/categories/Nginx/"}]},{"title":"Spring Boot整合Mybatis项目基本骨架（包括分页，mbg代码生成）","slug":"springboot1","date":"2020-05-24T07:59:24.000Z","updated":"2021-08-15T06:57:49.594Z","comments":false,"path":"2020/05/24/springboot1/","link":"","permalink":"http://example.com/2020/05/24/springboot1/","excerpt":"","text":"项目基本目录 注意：resources下的mbg生成的mapper.xml的文件夹不用建，自动生成 新建Spring Boot项目 新建Spring Boot项目，取好项目目录名和项目名，一路Next pom.xml 添加项目相关依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!--SpringBoot通用依赖模块--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--MyBatis分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--集成druid连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis 生成器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mysql数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 注：只要整合了PagerHelper就自动整合了MyBatis。 application.yml 配置端口、数据源、扫描路径 123456789101112server: port: 8080spring: datasource: url: jdbc:mysql://localhost:3306/deliverysystem?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;zeroDateTimeBehavior=CONVERT_TO_NULL username: root password: root driver-class-name: com.mysql.cj.jdbc.Drivermybatis: mapper-locations: - classpath:mapper/*.xml - classpath*:com/**/mapper/*.xml 新建包和文件 注：resources下的mbg生成的mapper.xml的文件不用建，自动生成 generator.properties 代码生成器数据源配置 1234567891011121314# jdbcjdbc.driverClass = com.mysql.cj.jdbc.Driverjdbc.connectionURL = jdbc:mysql://localhost:3306/deliverysystem?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;zeroDateTimeBehavior=CONVERT_TO_NULLjdbc.userId = rootjdbc.password = rootjdbc.maxPoolSize=50jdbc.minPoolSize=10jdbc.maxStatements=100jdbc.testConnection=true# mapper# mapper.plugin = tk.mybatis.mapper.generator.MapperPlugin# mapper.Mapper = com.jonychen.common.utils.CustomerMapper MyCommentGenerator.java 自定义代码注释生成器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import org.mybatis.generator.api.IntrospectedColumn;import org.mybatis.generator.api.IntrospectedTable;import org.mybatis.generator.api.dom.java.CompilationUnit;import org.mybatis.generator.api.dom.java.Field;import org.mybatis.generator.api.dom.java.FullyQualifiedJavaType;import org.mybatis.generator.internal.DefaultCommentGenerator;import org.mybatis.generator.internal.util.StringUtility;import java.util.Properties;/** * 自定义注释生成器 */public class MyCommentGenerator extends DefaultCommentGenerator &#123; private boolean addRemarkComments = false; private static final String EXAMPLE_SUFFIX=&quot;Example&quot;; // private static final String API_MODEL_PROPERTY_FULL_CLASS_NAME=&quot;io.swagger.annotations.ApiModelProperty&quot;; /** * 设置用户配置的参数 */ @Override public void addConfigurationProperties(Properties properties) &#123; super.addConfigurationProperties(properties); this.addRemarkComments = StringUtility.isTrue(properties.getProperty(&quot;addRemarkComments&quot;)); &#125; /** * 给字段添加注释 */ @Override public void addFieldComment(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) &#123; String remarks = introspectedColumn.getRemarks(); //根据参数和备注信息判断是否添加备注信息 if(addRemarkComments&amp;&amp;StringUtility.stringHasValue(remarks))&#123;// addFieldJavaDoc(field, remarks); //数据库中特殊字符需要转义 if(remarks.contains(&quot;\\&quot;&quot;))&#123; remarks = remarks.replace(&quot;\\&quot;&quot;,&quot;&#x27;&quot;); &#125; //给model的字段添加swagger注解 //field.addJavaDocLine(&quot;@ApiModelProperty(value = \\&quot;&quot;+remarks+&quot;\\&quot;)&quot;); &#125; &#125; /** * 给model的字段添加注释 */ private void addFieldJavaDoc(Field field, String remarks) &#123; //文档注释开始 field.addJavaDocLine(&quot;/**&quot;); //获取数据库字段的备注信息 String[] remarkLines = remarks.split(System.getProperty(&quot;line.separator&quot;)); for(String remarkLine:remarkLines)&#123; field.addJavaDocLine(&quot; * &quot;+remarkLine); &#125; addJavadocTag(field, false); field.addJavaDocLine(&quot; */&quot;); &#125; /* @Override public void addJavaFileComment(CompilationUnit compilationUnit) &#123; super.addJavaFileComment(compilationUnit); //只在model中添加swagger注解类的导入 if(!compilationUnit.isJavaInterface()&amp;&amp;!compilationUnit.getType().getFullyQualifiedName().contains(EXAMPLE_SUFFIX))&#123; compilationUnit.addImportedType(new FullyQualifiedJavaType(API_MODEL_PROPERTY_FULL_CLASS_NAME)); &#125; &#125;*/&#125; generatorConfig.xml 代码自动生成配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--加载配置文件，为下面读取数据库信息准备--&gt; &lt;properties resource=&quot;generator.properties&quot;/&gt; &lt;!-- context:生成一组对象的环境 id:必选，上下文id，用于在生成错误时提示 defaultModelType:指定生成对象的样式 1，conditional：类似hierarchical； 2，flat：所有内容（主键，blob）等全部生成在一个对象中； 3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class) targetRuntime: 1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample 2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample； introspectedColumnImpl：类全限定名，用于扩展MBG --&gt; &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号--&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;!-- 为模型生成序列化方法--&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt; &lt;!-- 为生成的Java模型创建一个toString方法 --&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt; &lt;!--覆盖生成XML文件--&gt;&lt;!--注意：这个pom.xml中MyBatis 生成器1.3.7版本才有--&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot; /&gt; &lt;!--可以自定义生成model的代码注释--&gt; &lt;!-- 阻止生成自动注释 --&gt; &lt;commentGenerator type=&quot;com.gxwz.deliverysystem.mbg.MyCommentGenerator&quot;&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--配置数据库连接--&gt; &lt;jdbcConnection driverClass=&quot;$&#123;jdbc.driverClass&#125;&quot; connectionURL=&quot;$&#123;jdbc.connectionURL&#125;&quot; userId=&quot;$&#123;jdbc.userId&#125;&quot; password=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt; &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt; &lt;/jdbcConnection&gt; &lt;!--指定生成model的路径--&gt;&lt;!--targetProject=&quot;E:\\ideaworkspace\\mallstudy\\src\\main\\java&quot; (填绝对路径)--&gt; &lt;javaModelGenerator targetPackage=&quot;com.gxwz.deliverysystem.mbg.model&quot; targetProject=&quot;E:\\ideaworkspace\\deliverysystem\\src\\main\\java&quot;/&gt; &lt;!--指定生成mapper.xml的路径--&gt; &lt;sqlMapGenerator targetPackage=&quot;com.gxwz.deliverysystem.mbg.mapper&quot; targetProject=&quot;E:\\ideaworkspace\\deliverysystem\\src\\main\\resources&quot;/&gt; &lt;!--指定生成mapper接口的的路径--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.gxwz.deliverysystem.mbg.mapper&quot; targetProject=&quot;E:\\ideaworkspace\\deliverysystem\\src\\main\\java&quot;/&gt; &lt;!--生成全部表tableName设为%--&gt; &lt;!--&lt;table tableName=&quot;%&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt; &lt;/table&gt;--&gt; &lt;!--要Example--&gt; &lt;table tableName=&quot;pms_brand&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt; &lt;/table&gt; &lt;!--不要Example--&gt; &lt;!--&lt;table tableName=&quot;cms_help&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt; &lt;/table&gt;--&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; Generator.java 代码生成器启动类 1234567891011121314151617181920212223242526272829303132333435import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.InputStream;import java.util.ArrayList;import java.util.List;/** * 用于生产MBG的代码 * Created by macro on 2018/4/26. */public class Generator &#123; public static void main(String[] args) throws Exception &#123; //MBG 执行过程中的警告信息 List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); //当生成的代码重复时，覆盖原代码 boolean overwrite = true; //读取我们的 MBG 配置文件 InputStream is = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(is); is.close(); DefaultShellCallback callback = new DefaultShellCallback(overwrite); //创建 MBG MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); //执行生成代码 myBatisGenerator.generate(null); //输出警告信息 for (String warning : warnings) &#123; System.out.println(warning); &#125; &#125;&#125; 运行Generator自动生成代码 MybatisConfig.java 用于配置需要动态生成的mapper接口的路径 123456789101112import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Configuration;/** * MyBatis配置类 * Created by macro on 2019/4/8. */@Configuration@MapperScan(&quot;com.gxwz.deliverysystem.mbg.mapper&quot;)public class MyBatisConfig &#123;&#125; 编写Service接口123456789101112131415161718192021import com.gxwz.deliverysystem.mbg.model.User;import java.util.List;/** * @author fengxiao * @date 2020/2/23 17:28 */public interface UserService &#123; int createUser(User user); int deleteUser(Long id); int updateUser(Long id, User user); List&lt;User&gt; listAllUser(); List&lt;User&gt; listUser(int pageNum, int pageSize); User getUser(Long id);&#125; 编写Service接口实现类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import com.github.pagehelper.PageHelper;import com.gxwz.deliverysystem.mbg.mapper.UserMapper;import com.gxwz.deliverysystem.mbg.model.User;import com.gxwz.deliverysystem.mbg.model.UserExample;import com.gxwz.deliverysystem.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import java.util.List;/** * @author fengxiao * @date 2020/2/23 17:36 */public class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public int createUser(User user)&#123; return userMapper.insert(user); &#125; @Override public int deleteUser(Long id)&#123; return userMapper.deleteByPrimaryKey(id); &#125; @Override public int updateUser(Long id, User user)&#123; user.setId(id); return userMapper.updateByPrimaryKey(user); &#125; @Override public List&lt;User&gt; listAllUser()&#123; return userMapper.selectByExample(new UserExample()); &#125; //分页显示 @Override public List&lt;User&gt; listUser(int pageNum, int pageSize)&#123; PageHelper.startPage(pageNum, pageSize); return userMapper.selectByExample(new UserExample()); &#125; @Override public User getUser(Long id)&#123; return userMapper.selectByPrimaryKey(id); &#125;&#125; 添加common.api 包括对分页数据和返回结果的封装类 编写Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import com.gxwz.deliverysystem.common.api.CommonPage;import com.gxwz.deliverysystem.common.api.CommonResult;import com.gxwz.deliverysystem.mbg.model.User;import com.gxwz.deliverysystem.service.UserService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.*;import java.util.List;/** * @author fengxiao * @date 2020/2/23 18:00 */@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; private static final Logger LOGGER = LoggerFactory.getLogger(UserController.class); /** * 获取所有User * @return */ @RequestMapping(value = &quot;/listAll&quot;, method = RequestMethod.GET) @ResponseBody public CommonResult&lt;List&lt;User&gt;&gt; getUserlist()&#123; return CommonResult.success(userService.listAllUser()); //成功时返回结果对象 &#125; /** * 添加User * @param user * @return */ @RequestMapping(value = &quot;/create&quot;, method = RequestMethod.POST) @ResponseBody public CommonResult createUser(@RequestBody User user) &#123; CommonResult commonResult; int count = userService.createUser(user); if (count == 1) &#123; commonResult = CommonResult.success(user); LOGGER.debug(&quot;createUser success:&#123;&#125;&quot;, user); &#125; else &#123; commonResult = CommonResult.failed(&quot;操作失败&quot;); LOGGER.debug(&quot;createUser failed:&#123;&#125;&quot;, user); &#125; return commonResult; &#125; /** * 根据id修改User * @param id * @param user * @param result * @return */ @RequestMapping(value = &quot;/update/&#123;id&#125;&quot;, method = RequestMethod.POST) @ResponseBody public CommonResult updateUser(@PathVariable(&quot;id&quot;) Long id, @RequestBody User user, BindingResult result) &#123; CommonResult commonResult; int count = userService.updateUser(id, user); if (count == 1) &#123; commonResult = CommonResult.success(user); LOGGER.debug(&quot;updateUser success:&#123;&#125;&quot;, user); &#125; else &#123; commonResult = CommonResult.failed(&quot;操作失败&quot;); LOGGER.debug(&quot;updateUser failed:&#123;&#125;&quot;, user); &#125; return commonResult; &#125; /** * 根据id删除User * @param id * @return */ @RequestMapping(value = &quot;/delete/&#123;id&#125;&quot;, method = RequestMethod.GET) @ResponseBody public CommonResult deleteUser(@PathVariable(&quot;id&quot;) Long id) &#123; int count = userService.deleteUser(id); if (count == 1) &#123; LOGGER.debug(&quot;deleteUser success :id=&#123;&#125;&quot;, id); return CommonResult.success(&quot;操作成功&quot;); &#125; else &#123; LOGGER.debug(&quot;deleteUser failed :id=&#123;&#125;&quot;, id); return CommonResult.failed(&quot;操作失败&quot;); &#125; &#125; /** * 分页获取User * @param pageNum * @param pageSize * @return */ @RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET) @ResponseBody public CommonResult&lt;CommonPage&lt;User&gt;&gt; listBrand(@RequestParam(value = &quot;pageNum&quot;, defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(value = &quot;pageSize&quot;, defaultValue = &quot;5&quot;) Integer pageSize) &#123; List&lt;User&gt; userList = userService.listUser(pageNum, pageSize); return CommonResult.success(CommonPage.restPage(userList)); &#125; /** * 根据id获取User * @param id * @return */ @RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET) @ResponseBody public CommonResult&lt;User&gt; brand(@PathVariable(&quot;id&quot;) Long id) &#123; return CommonResult.success(userService.getUser(id)); &#125;&#125; 运行项目启动类测试","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://example.com/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://example.com/tags/Spring-Boot/"}],"keywords":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://example.com/categories/Spring-Boot/"}]}]}