{"meta":{"title":"Fengx","subtitle":"冯晓的博客","description":"冯晓的博客","author":"Fengx","url":"http://example.com"},"pages":[{"title":"tags","date":"2021-08-13T06:55:00.000Z","updated":"2021-08-13T06:55:00.397Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-13T06:55:07.000Z","updated":"2021-08-13T06:55:07.722Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构基础知识","slug":"csbase1","date":"2021-05-30T08:11:49.000Z","updated":"2021-08-14T02:41:20.551Z","comments":false,"path":"2021/05/30/csbase1/","link":"","permalink":"http://example.com/2021/05/30/csbase1/","excerpt":"","text":"概述数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。不同的数据结构具有各自对应的适用场景，旨在降低各种算法计算的时间与空间复杂度，达到最佳的任务执行效率。 分类线性数据结构（物理结构）数组(Array)、链表(Linked List)、栈(Stack)、队列(Queue) 非线性数据结构（逻辑结构）树(Tree)、堆(Heap)、散列表(Hashing)、图(Graph) 数组数组是将相同类型的元素存储于连续内存空间的数据结构，其长度不可变。 如下图所示，构建此数组需要在初始化时给定长度，并对数组每个索引元素赋值，代码如下： 12345678// 初始化一个长度为 5 的数组 arrayint[] array = new int[5];// 元素赋值array[0] = 2;array[1] = 3;array[2] = 1;array[3] = 0;array[4] = 2; 或者可以使用直接赋值的初始化方式，代码如下： 1int[] array = &#123;2, 3, 1, 0, 2&#125;; 可变数组可变数组是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。 123456789// 初始化可变数组List&lt;Integer&gt; array = new ArrayList&lt;&gt;();// 向尾部添加元素array.add(2);array.add(3);array.add(1);array.add(0);array.add(2); 链表链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。链表的节点对象具有两个成员变量：「值 val」，「后继节点引用 next」。 12345class ListNode &#123; int val; // 节点值 ListNode next; // 后继节点引用 ListNode(int x) &#123; val = x; &#125;&#125; 如下图所示，建立此链表需要实例化每个节点，并构建各节点的引用指向。 12345678// 实例化节点ListNode n1 = new ListNode(4); // 节点 headListNode n2 = new ListNode(5);ListNode n3 = new ListNode(1);// 构建引用指向n1.next = n2;n2.next = n3; 栈栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。 1Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); 如下图所示，通过常用操作 「入栈 push()」,「出栈 pop()」，展示了栈的先入后出特性。 1234stack.push(1); // 元素 1 入栈stack.push(2); // 元素 2 入栈stack.pop(); // 出栈 -&gt; 元素 2stack.pop(); // 出栈 -&gt; 元素 1 注意：通常情况下，不推荐使用 Java 的 Vector 以及其子类 Stack ，而一般将 LinkedList 作为栈来使用。 123456LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;();stack.addLast(1); // 元素 1 入栈stack.addLast(2); // 元素 2 入栈stack.removeLast(); // 出栈 -&gt; 元素 2stack.removeLast(); // 出栈 -&gt; 元素 1 队列队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。 1Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); 如下图所示，通过常用操作 「入队 push()」,「出队 pop()」，展示了队列的先入先出特性。 1234queue.offer(1); // 元素 1 入队queue.offer(2); // 元素 2 入队queue.poll(); // 出队 -&gt; 元素 1queue.poll(); // 出队 -&gt; 元素 2 树树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为 「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。 123456class TreeNode &#123; int val; // 节点值 TreeNode left; // 左子节点 TreeNode right; // 右子节点 TreeNode(int x) &#123; val = x; &#125;&#125; 如下图所示，建立此二叉树需要实例化每个节点，并构建各节点的引用指向。 123456789101112// 初始化节点TreeNode n1 = new TreeNode(3); // 根节点 rootTreeNode n2 = new TreeNode(4);TreeNode n3 = new TreeNode(5);TreeNode n4 = new TreeNode(1);TreeNode n5 = new TreeNode(2);// 构建引用指向n1.left = n2;n1.right = n3;n2.left = n4;n2.right = n5; 图图是一种非线性数据结构，由 「节点（顶点）vertex」 和 「边 edge」 组成，每条边连接一对顶点。根据边的方向有无，图可分为 「有向图」 和 「无向图」 。 如下图所示，此无向图的 顶点 和 边 集合分别为： 顶点集合： vertices = {1, 2, 3, 4, 5} 边集合： edges = {(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)} 表示图的方法通常有两种： 1、邻接矩阵： 使用数组 verticesvertices 存储顶点，邻接矩阵 edgesedges 存储边；edges[i][j] 代表节点 i + 1和节点 j + 1之间是否有边。 123456int[] vertices = &#123;1, 2, 3, 4, 5&#125;;int[][] edges = &#123;&#123;0, 1, 1, 1, 1&#125;, &#123;1, 0, 0, 1, 0&#125;, &#123;1, 0, 0, 0, 1&#125;, &#123;1, 1, 0, 0, 1&#125;, &#123;1, 0, 1, 1, 0&#125;&#125;; 2、邻接表： 使用数组vertices存储顶点，邻接表edges存储边。 edges为一个二维容器，第一维 i 代表顶点索引，第二维 edges[i] 存储此顶点对应的边集和；例如 edges[0] = [1, 2, 3, 4]代表 vertices[0]的边集合为 [1, 2, 3, 4]。 12345678910111213int[] vertices = &#123;1, 2, 3, 4, 5&#125;;List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();List&lt;Integer&gt; edge_1 = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4));List&lt;Integer&gt; edge_2 = new ArrayList&lt;&gt;(Arrays.asList(0, 3));List&lt;Integer&gt; edge_3 = new ArrayList&lt;&gt;(Arrays.asList(0, 4));List&lt;Integer&gt; edge_4 = new ArrayList&lt;&gt;(Arrays.asList(0, 1, 4));List&lt;Integer&gt; edge_5 = new ArrayList&lt;&gt;(Arrays.asList(0, 2, 3));edges.add(edge_1);edges.add(edge_2);edges.add(edge_3);edges.add(edge_4);edges.add(edge_5); 邻接矩阵 VS 邻接表 ： 邻接矩阵的大小只与节点数量有关，即N^2，其中N为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。因此，邻接表 适合存储稀疏图（顶点较多、边较少）；邻接矩阵适合存储稠密图（顶点较少、边较多）。 散列表散列表是一种非线性数据结构，通过利用 Hash 函数将指定的 「键 key」 映射至对应的 「值 value」 ，以实现高效的元素查找。 设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。现需求从「姓名」查找「学号」。 则可通过建立姓名为 key ，学号为 value 的散列表实现此需求，代码如下： 123456789101112// 初始化散列表Map&lt;String, Integer&gt; dic = new HashMap&lt;&gt;();// 添加 key -&gt; value 键值对dic.put(&quot;小力&quot;, 10001);dic.put(&quot;小特&quot;, 10002);dic.put(&quot;小扣&quot;, 10003);// 从姓名查找学号dic.get(&quot;小力&quot;); // -&gt; 10001dic.get(&quot;小特&quot;); // -&gt; 10002dic.get(&quot;小扣&quot;); // -&gt; 10003 自行设计 Hash 函数： 假设需求：从「学号」查找「姓名」。 将三人的姓名存储至以下数组中，则各姓名在数组中的索引分别为 0, 1, 2。 1String[] names = &#123; &quot;小力&quot;, &quot;小特&quot;, &quot;小扣&quot; &#125;; 此时，我们构造一个简单的Hash函数（%为取余符号），公式和封装函数如下所示： hash(key) = (key - 1) % 10000 1234int hash(int id) &#123; int index = (id - 1) % 10000; return index;&#125; 则我们构建了以学号为 key 、姓名对应的数组索引为 value 的散列表。利用此 Hash 函数，则可在 O(1) 时间复杂度下通过学号查找到对应姓名，即： 123names[hash(10001)] // 小力names[hash(10002)] // 小特names[hash(10003)] // 小扣 以上设计只适用于此示例，实际的 Hash 函数需保证低碰撞率、高鲁棒性(健壮性)等，以适用于各类数据和场景。 堆堆是一种基于 「完全二叉树」 的数据结构，可使用数组实现。以堆为原理的排序算法称为 「堆排序」 ，基于堆实现的数据结构为 「优先队列」 。堆分为 「大顶堆」 和 「小顶堆」 ，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。 完全二叉树定义： 设二叉树深度为 k ，若二叉树除第 k 层外的其它各层（第 1 至 k−1 层）的节点达到最大个数，且处于第 k 层的节点都连续集中在最左边，则称此二叉树为完全二叉树。 如下图所示，为包含 1, 4, 2, 6, 8 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式。 通过使用「优先队列」的「压入 push()」和「弹出pop()」操作，即可完成堆排序，实现代码如下： 12345678910111213141516// 初始化小顶堆Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;();// 元素入堆heap.add(1);heap.add(4);heap.add(2);heap.add(6);heap.add(8);// 元素出堆（从小到大）heap.poll(); // -&gt; 1heap.poll(); // -&gt; 2heap.poll(); // -&gt; 4heap.poll(); // -&gt; 6heap.poll(); // -&gt; 8","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"keywords":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Java基础（复习整理）","slug":"java1","date":"2021-05-03T15:10:09.000Z","updated":"2021-08-14T03:51:52.229Z","comments":true,"path":"2021/05/03/java1/","link":"","permalink":"http://example.com/2021/05/03/java1/","excerpt":"","text":"基础知识和语法Java语言初识 计算机语言发展 机器语言、汇编、C、C++、Java Java的诞生与发展 1995 JavaSE JavaME Android JavaEE 2006(大数据) Hadoop Spark 流式计算 Scala JDK 开发工具包 配置环境变量 JAVA_HOME D:\\JDK8_211 path ;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin CLASSPATH .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 验证安装DOS java -version JRE Java程序运行环境 包含JVM，Java程序运行 跨平台原理 在JVM上运行，无视操作系统 HelloWorld javac Hello.java 生成class文件 java Hello 运行编译好的class文件 编译型和解释型语言 Java是半编译半解释型语言 IDEA 主流开发工具 注释 行内 // 多行 /* */ 文档 /** */ javadoc 命令 生成帮助文档 标识符 关键字 语法规则 大小写敏感 类名首字母大写 方法名小写 源文件名与类名必须相同，后缀名为.java 一个源文件只能有一个public类，可以有多个其他类（内部类、匿名类） 所有程序由主方法入口开始执行 public static void main(String[] args) 标识符 以字母、美元符、下划线开头，不能用数字开头 关键字不能做标识符 数据类型 基本数据类型 整型 byte Byte 8位，1字节 -128(-2^7) ~ 127(2^7-1) short Short 16位，2字节 -32768(-2^15) ~ 32767(2^15-1) int Integer 32位，4字节 -2^31 ~ 2^31-1 整型变量默认为int型 long Long 64位，8字节 -2^63 ~ 2^63 默认值：0L 浮点型 float Float 32位，4字节 默认值：0.0f double Double 64位，8字节 浮点数 金融计算 BigDecimal 字符型 char(Unicode字符) Character 16位，2字节 单引号，‘A’ 字符编码 ASCII UTF-8 Unicode ‘\\u0000’（转义） \\b 退格 \\n 换行 \\r 回车 \\t 制表 &#39; &quot; \\ 布尔型 boolean Boolean 1字节 true/false 默认值：false 引用数据类型 数组 int[] a = {1,2,3,4}; 类（对象） class Hero; 栈指向堆 栈存放对象引用的地址 堆存放对象的信息，栈存放该对象的地址，所以栈指向堆 接口 interface Hero; 默认值：null == 和 equals == 基本类型：比较的是值是否相同 引用类型：比较的是引用是否相同 equals equals 本质上就是 ==，但重写了String和Integer，把引用比较改成了值比较 数据类型转换 自动类型转换 转换原则：从低精度向高精度转换byte-&gt;(short、char)-&gt;int-&gt;long-&gt;float-&gt;double 表数范围小的自动转换为表数范围大的 运算有多种数据类型结果自动转换为最大的数据类型 字符串与任何数据类型相连都会转换为字符串类型 两个char型运算时，自动转换为int型；当char与别的类型运算时，也会先自动转换为int型的，再做其它类型的自动转换 byte和short不能和char相互转换，char值范围为0~65535，byte和short都包含负数 强制类型转换 表数大的转表数小的需要强制转换 运算符为(),括号里写小的数据类型 byte b = (byte)12 装箱和拆箱 装箱：int-&gt;Integer 拆箱：Integer-&gt;int Java包装类的缓存 具体的实现方式为在类中预先创建频繁使用的包装类对象，当需要使用某个包装类的对象时，如果该对象封装的值在缓存的范围内，就返回缓存的对象，否则创建新的对象并返回 哪些包装类没有缓存 float、double 常量 定义 final修饰常量 一般大写命名 final String DEMO = “HELLO”; final 只允许初始化一次 一般与static一起使用 静态不可变 变量 定义 int a = 2; 作用域 类变量 静态变量 必须声明为static类型 局部变量不能被声明为类变量 实例(成员)变量 非静态变量 类之中，方法外，可全局使用 局部变量 方法内，仅限于方法内使用 命名规范 1、见名知意 2、驼峰命名（变量和方法） 3、类，首字母大写，驼峰命名 4、常量，大写+下划线 5、不要使用拼音命令 运算符 算术运算符 +、-、*、/、%、++、– 赋值运算符 = 关系运算符 ‘&gt;’、&lt;、&gt;=、&lt;= 逻辑运算符 &amp;&amp;、||、！ 位运算符 &amp;、|、^、~、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt; 扩展运算符 +=、-=、*=、/= 三目运算符 条件？true的取值:false的取值 优先级 尽量使用 小括号，可读性更好 instanceof 检查当前对象是否是某个特定类型 包机制 域名倒写 package import 为了防治命名冲突 用于放功能相似或相关类 JavaDoc 生成JDK帮助文档 javadoc @author 作者 @Version 版本 @since 最早支持到哪个版本能够使用 @param 参数 @return 返回 @throws 异常 编译文件、生成帮助文档 教程：https://www.bilibili.com/video/BV12J41137hu?p=80 34：11 流程控制 Scanner 用户交互 System.in 顺序结构 程序默认结构，自上而下的执行 选择结构 if 单选择结构 if-else 双选择结构 if-else if-else 多选择结构 switch JDK7支持了String类型 case穿透现象，不加break 就会继续执行下一个case break default 默认，case没有就执行这个 循环结构 while 满足条件后执行 尽量避免死循环 一般不可计次数循环时使用 do…while 至少执行一次，先执行 for for(int i = 0; i &lt; 100; i++) 一般可计次数循环时使用 for-each - for(int num : nums) 增强型for循环 编程：打印九九乘法表 break &amp; continue &amp; return break 跳出循环 continue 终止本次循环，进入下一次循环 return 结束方法的运行 数组 定义 new int[5] 分配好空间 {1,2,3,4} 数组存放的值必须是同一个类型 存储在堆上的对象，可保存多个同类型变量 数组初始化，内存所占空间固定，长度不可改变 静态初始化 int demoArray[3] = {1,2,3}; 动态初始化 int demoArray[10]; 使用 通过下标拿到值 ArrayIndexOutOfBounds 数组下标越界异常 for-each遍历 遍历 数组索引从0开始 for (int i = 0; i &lt; myList.length; i++) {System.out.println(myList[i] + “ “);} for each循环 for (double element: myList) {System.out.println(element);} 二维数组 int[][] Arrays 工具类 方法 排序 sort() sort排序原理 使用了两种排序方法，快速排序和优化的归并排序 快速排序主要是对那些基本类型数据排序，而归并排序用于对Object类型进行排序。 比较 equals() 转为字符串 toString() 排序算法 冒泡排序 选择排序 插入排序 快速排序 归并排序 希尔排序 堆排序 基数排序（桶排序） 笔试：要求手写 面向对象什么是面向对象 一个人就是一个对象，属性：名字，方法：动作 类与对象 类 是Java最小的程序单元 是一个模板，描述对象的状态和行为 是对象的集合 由class定义 对象 Java中除了8个基本数据类型值外，一切都是对象 声明 由类声明 实例化 new创建对象实例化 初始化 创建对象时调用构造方法进行初始化 属性 对象的状态 方法 对象的行为操作 new 对象 栈 存放引用 堆 存放具体对象信息 构造方法 构造的重载 默认无参构造 如果手动定义了有参构造就必须要手动再加一个无参构造 单例模式需要构造器私有，为的就是不让别人去new它，只能创建一个对象 new需要构造方法来创建对象 与类同名，无返回值无void，可以有参数,只能与new结合使用，返回的是类的实例 如果不显式定义构造方法，编译器会为该类隐式提供默认的构造方法 每个类至少一个构造方法（可以有多个），方法名与类名必须相同 方法 语句的集合 定义 修饰符 返回值 方法名(参数名) { return 返回值; } 方法调用 类名.方法 对象.方法 方法重载 名字相同，参数列表不同 命令行传参 给main方法传参 教程：https://www.bilibili.com/video/BV12J41137hu?p=80 45：22 必须掌握，后面JVM调优传参就是这样传，在后面传JVM参数 可变长参数 … 必须放在最后一个参数 递归 自己调用自己，给自己一个出口 时间复杂度高 面试常问 刷leetcode 基础题 封装 属性私有，提供对应get，set 方法 减少耦合 隐藏实现细节 容易理解 继承 关键字 extends super 访问父类成员 super.eat(); this 访问自己 this.eat(); 子类继承父类，继承包括非private修饰的成员变量，方法 减少重复代码，提高代码复用性，提高维护性 不支持多继承，但支持多重继承、不同类继承同一个类 变相多继承 implements 可以实现多个接口 多态 父类的引用指向子类的对象 Person person = new Student(); 引用 person 指向 Student 对象 instanceof 如匹配，可以进行类型之间转换 返回：true / false 同一个行为具有多个不同的表现形式 例子：同一个接口，使用不同实例执行不同的操作 存在的必要条件 继承 重写 父类引用指向子类对象 实现 重写 接口 抽象类 编译时多态通过方法重载 重载只能通过不同的方法参数区分 参数个数不同 参数类型不同 通过指向父类的指针，来调用在不同子类中实现的方法 运行时多态通过方法重写 多态用到了动态绑定 编译时类型与运行时类型不一致就会发生运行时动态绑定（典型的就是重载） Override、Overload 重载 一个类中，两个方法同名，但形参不同（数量，类型不同），返回值可同可不同 重写 方法名，形参和返回值必须相同 子类可以根据自己的需要实现父类的方法 向上转型与向下转型 向上转型：是子类对象由父类引用，格式：parent p = new son 向下转型：是父类向下强制转换到子类对象，前提是该父类对象必须是经过向上转型的对象 对进行过上转型的对象，进行强制下转型Son s = (Son)p; 修饰符 访问修饰符 private 同一个类内 defalt 同一个包内 protected 同一个包内和所有子类 public 所有类 非访问修饰符 static 用来修饰类方法和类变量 静态方法只能用静态变量(static修饰的) final final通常和static一起使用 修饰的类 不能被继承 修饰的方法 不能被重写 修饰的变量 不能被修改 abstract 唯一目的：将来对类进行扩充 用来创建抽象类和抽象方法 类有抽象方法一定要声明为抽象类（抽象类可以没有抽象方法） synchronized 和 volatile 主要用于多线程编程 synchronized修饰的方法只能同一时间只能被一个线程访问 volatile 接口 interface 约束，只能定义方法名 子类实现接口必须重写其中方法 只有一个方法的接口叫做函数式接口，可以使用lambda表达式简化 抽象类 接口比抽象类更抽象，接口不能有实现 抽象类可以有具体的实现 一个类可以实现多个接口 抽象类 abstract 用来创建抽象类和抽象方法 唯一目的：将来对类进行扩充 不能被实例化，必须被继承才能使用，通常在设计阶段决定是否使用 类有抽象方法一定要声明为抽象类（抽象类可以没有抽象方法） 子类继承抽象类，父类有抽象方法子类必须重写抽象方法 抽象类和接口区别 一个类只可以继承一个抽象类，但可以实现多个接口 抽象类可以有构造方法，接口中不能有构造方法 抽象类可以有普通的成员变量，接口中不能有普通的成员变量 抽象类中可以包含静态方法，接口中不能包含静态方法 内部类 定义 将一个类定义在另一个类或方法中 分类 成员内部类 定义在一个类中 局部内部类 定义在一个方法或作用域中 匿名内部类 使用最多 主要编写事件监听代码 lambda 静态内部类 定义在一个类中，static修饰 深入 编译器编译成多个class文件 克隆 浅克隆 浅克隆不会克隆原对象中的引用类型，仅仅拷贝了引用类型的指向 深克隆 深克隆的实现就是在引用类型所在的类实现Cloneable接口，并使用public访问修饰符重写clone方法。 序列化 对象中被 static 或 transient 修饰的变量，在序列化时不被保存 Enum类 为什么构造函数必须是私有的 为了保证每一个枚举类元素的唯一实例，是不会允许外部进行new的 常用APIScanner 键盘输入 Random 生成随机数 Arrays 数组工具类 排序 查找 String 不可变性 final修饰 方法 构造方法 String(char[]) String(byte[],Charset) 字节流，编码 String(StringBuffer) 将StringBuffer转换为String String(StringBuilder) 将StringBuilder转换为String length() 长度 isEmpty() 判空 charAt(int index) 获取指定字符串 getBytes(String charsetName) String变成字节数组 indexOf(int ch) 获取指定下标 subString(int beginIndex) 截取字符串 concat(String str) 包含某个字符串 replace(char oldChar, char newChar) 替换字符串 replaceAll(String, String) 替换全部 split(String, int) 字符串分割成数组 常用 trim() 去掉字符串两边空格 StringBuilder、StringBuffer类 StringBuffer是线程安全的（速度慢，需要同步） StringBuilder不是线程安全的（没有被synchronized（同步）修饰） StringBuffer 可变长 原因：append() 本质：拷贝成新的再返回，还是利用的String 线程安全 synchronized修饰 效率较低 多线程使用 StringBuilder 可变长 原因：append() 本质：拷贝成新的再返回，还是利用的String 单线程下 字符串缓存区大，数据量大使用 数据小使用String 操作量较少 非线程安全 但效率高 原因：不用同步 ArrayList 数组列表 长度可变 类型统一 一般和泛型使用 ArrayList list = ArrayList&lt;&gt;(); Math 数学相关工具类 Date类 时间日期类 当前日期时间 date.toString 格式化日期 SimpleDateFormat ft = new SimpleDateFormat (“yyyy-MM-dd hh:mm:ss”); 正则表达式 用字符串描述的匹配规则 判断年份是否是’20##’ ，通过 String x = “20\\d\\d”; 判断 \\d，表示0~9的数 一般用于数据校验 Object hashcode() toString() clone() getClass() notify() 通知，多线程使用 wait() equals() File 创建文件 查看文件 修改文件 删除文件 包装类 自动装箱与拆箱 八大基本类型不是类，不是面向对象，需要封装成类 异常处理总接口 Throwable Exception 捕获不到需要提升到Throwable，不能捕获Error 自定义异常 继承或实现Exception 接口 运行时异常 1/0 ClassNotFound NullPoint 空指针 UnKnowType 未知类型 下标越界异常 文件类型异常……. 编译会通过，需要手动捕获处理，注意 出现这类异常的时候程序会由虚拟机接管 检查型异常 一般不管，因为编译不会通过 Error AWT 错误 JVM 错误 StackOverFlow 栈溢出 递归会导致错误 OutOfMemory OOM Java内存溢出 一个数字太大，不断创建对象，内存占用满了会导致错误 面试常问 处理 try{} 尝试运行 catch () {} 捕获 先捕获小异常再捕获大异常 finally() 无论是否出现异常，finally中的代码都会被执行 throw 方法内部，手动抛出异常 throws 方法抛出异常","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"Java后端知识体系","slug":"knowledge1","date":"2021-04-26T05:46:50.000Z","updated":"2021-08-13T15:45:45.029Z","comments":false,"path":"2021/04/26/knowledge1/","link":"","permalink":"http://example.com/2021/04/26/knowledge1/","excerpt":"","text":"纸上得来终觉浅，绝知此事要躬行 看书看的起劲是什么时候，能回想到自己写代码，终于知道为什么要这么写，有种茅塞顿开的感觉，那才叫爽。 基础重点(必须扎实)Java语言 语言基础 《Java核心技术》 基础语法 面向对象 常用API 异常处理 集合 IO 多线程 网络编程 泛型 反射 注解 JVM 《深入理解Java虚拟机》 类加载机制 双亲委托 字节码执行机制 JVM内存模型 堆区 虚拟机栈 方法区 GC垃圾回收 JVM性能监控与故障定位 JVM调优 多线程、锁、并发 1:《Java并发编程的艺术》、2:《Java并发编程实战》 并发编程基础 线程池 锁 乐观锁、悲观锁 互斥锁、共享锁 可重入锁、偏向锁 轻量级锁、CAS与自旋锁 并发容器 原子类 JUC并发工具类 网络编程 学习路径 Socket API + 多线程 + 网络模型/IO模型 + IO复用 Netty 核心点 进程间通信方式：信号量、管道、共享内存、socket 等 多线程编程：互斥锁、条件变量、读写锁、线程池等 五大 IO 模型：同步、异步、阻塞、非阻塞、信号驱动 高性能 IO 两种模式：Reactor 和 Proactor IO 复用机制：epoll、select、poll（破解 C10K 问题的利器） Java源码 数据库/SQL 《SQL必知必会》、《高性能MySQL》 SQL语句 手写SQL 联表 聚合 SQL语句优化 事务、隔离级别 索引 锁 数据结构与算法 《漫画算法》、《算法》 数据结构 字符串 数组 链表 栈 队列 二叉树 堆 哈希 算法 十大排序 查找、二分 贪心 分治 动态规划 回溯 设计模式 《重学Java设计模式》 单例 工厂 代理 策略 模板方法 观察者 适配器 责任链 建造者 。。。。 计算机网络 《计算机网络：自顶向下方法》 HTTP、TCP、IP、ICMP、UDP、DNS、ARP IP地址、MAC地址、OSI七层模型（或者 TCP/IP 五层模型） HTTPS安全相关的：数字签名、数字证书、TLS 常见网络攻击：局域网ARP泛洪、DDoS、TCP SYN Flood、XSS等 TCP协议（最重要） TCP协议 三次握手、四次挥手 状态转换 TCP状态中TIME_WAIT 拥塞控制 快速重传、慢启动 问题 TCP 如何实现可靠传输的（画外音：如何基于 UDP 实现可靠传输） TCP 连接建立为什么不是两次握手（画外音：三次握手的充分必要性说明） TIME_WAIT 的存在解决了什么问题，等待时间为什么是 2 MSL 核心 可靠传输 + 高效传输（流量控制和窗口管理） HTTP、HTTPS 从 URL 输入到页面展现到底发生什么 学习方法 学习抓住一条主线 一个数据包是如何发送出去的 带着问题去思考为什么这么做 操作系统 《现代操作系统》 进程管理 并发、同步互斥、锁 内存管理 文件系统 重点 OS四大模块的理论知识 进程与线程管理 内存管理 IO与文件系统 设备管理 了解Linux内核部分实现原理 内存管理 进程管理 虚拟文件系统 与编程最密切 内存 进程 IO 认知 操作系统由哪些构成 进程的状态、切换、调度 进程间通信方式（共享内存、管道、消息） 进程和线程的区别 线程的实现方式（一对一、多对一等） 互斥与同步（信号量、管程、锁） 死锁检测与避免 并发经典的问题：读者写者、哲学家就餐问题 为什么需要虚拟内存，MMU 具体如何做地址转换的 内存为什么分段、分页 页面置换算法 文件系统是如何组织的 虚拟文件系统（VFS）是如何抽象的 。。。。 应用框架后端 JSP、Servlet Spring家族 Spring IOC AOP Spring MVC MyBatis SSM 打war包 Tomcat运行 Spring Boot 打jar包 内嵌Tomcat 微服务架构 知识点 自动配置、开箱即用 整合Web 整合数据库（事务问题） 整合权限 Shiro SpringSecurity 各种中间件 缓存 MQ RPC框架 Dubbo NIO框架 Netty Spring Cloud Netflix Eureka 服务治理组件，包括服务端的注册中心和客户端的服务发现机制。 Ribbon 负载均衡的服务调用组件，具有多种负载均衡调用策略。 Hystrix 服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力。 Feign 基于Ribbon和Hystrix的声明式服务调用组件。 Zuul API 网关服务，过滤、安全、监控、限流、路由。 Alibaba Nacos 阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Sentinel 面向分布式服务架构的轻量级流量控制产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 RocketMQ 一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo Apache Dubbo 是一款高性能 Java RPC 框架，用于实现服务通信。 Seata 阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Config 分布式配置中心。配置管理工具，支持使用 Git 存储配置内容，支持应用配置的外部化存储，支持客户端配置信息刷新、加解密配置内容等。 Bus 事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。 Consul 服务注册和配置管理中心。 Security 安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。 Sleuth SpringCloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。 Stream 轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。 Task 用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。 Zookeeper 服务注册中心。 Gateway（可替代 Zuul） Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方式。Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。 OpenFeign（可替代 Feign） OpenFeign 是 Spring Cloud 在 Feign 的基础上支持了 Spring MVC 的注解，如 @RequesMapping等等。OpenFeign 的 @FeignClient 可以解析 SpringMVC 的 @RequestMapping 注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。 项目经验 总结 中间件 缓存 Redis 5大数据类型 事务 消息通知 管道 持久化 集群 消息 RabbitMQ RocketMQ Kafka 搜索 ElasticSearch 前端 基础套餐 三大件 HTML CSS JavaScript 基础库 jQuery Ajax 模板框架 JSP Thymeleaf FreeMaker 组件化框架 Node VUE React Angular 开发工具集成开发环境 Eclipse IDEA VSCode Linux系统 Linux常用命令 基本Shell脚本 代码管理工具 Git Git命令和使用 SVN 项目管理/构建工具 Maven Gradle 应用运维Web服务器 Nginx 应用服务器 Tomcat 容器技术 Docker Kubernetes(K8S) 管理运维容器 持续集成、持续发布 Jenkins 代码质量检测 Sonar 日志收集、分析 ELK CDN加速","categories":[{"name":"知识体系","slug":"知识体系","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"知识体系","slug":"知识体系","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}],"keywords":[{"name":"知识体系","slug":"知识体系","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}]},{"title":"设计模式学习记录（一）代理模式","slug":"designpattern1","date":"2021-04-11T15:10:58.000Z","updated":"2021-08-14T03:28:37.588Z","comments":false,"path":"2021/04/11/designpattern1/","link":"","permalink":"http://example.com/2021/04/11/designpattern1/","excerpt":"","text":"前言为什么要学设计模式？？工作一年多了，也写了一年多的业务代码，if else 用的炉火纯青，一个 if else 不行就两个 else if 哈哈，然后就变成了一坨。。，这谁顶得住啊，不行，写代码一定要优雅~~，在合适的场景使用合适的设计模式，重用代码、让代码更容易被他人理解、保证代码可靠性。 代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 1、创建一个接口123456789101112package com.fengx.design_patterns.proxy_pattern;/** * @author: Fengx * @create: 2021-06-24 * @description: 1、创建一个接口 **/public interface Image &#123; void display();&#125; 2、创建实现接口的实体类12345678910111213141516171819202122232425package com.fengx.design_patterns.proxy_pattern;/** * @author: Fengx * @create: 2021-06-24 * @description: 2、创建实现接口的实体类 **/public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display()&#123; System.out.println(&quot;展示：&quot; + fileName); &#125; private void loadFromDisk(String fileName)&#123; System.out.println(&quot;第一次从加载对象 &quot; + fileName); &#125;&#125; 3、创建Image的代理类12345678910111213141516171819202122232425package com.fengx.design_patterns.proxy_pattern;/** * @author: Fengx * @create: 2021-07-05 * @description: 3、创建Image的代理类 **/public class ProxyImage implements Image&#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display()&#123; // 当被请求时，使用 ProxyImage 来获取 RealImage 类的对象 if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125; 4、当被请求时，使用 ProxyImage 来获取 RealImage 类的对象1234567891011public class ProxyPatternDemo &#123; public static void main(String[] args) &#123; Image image = new ProxyImage(&quot;fengx.jpg&quot;); // 图像第一次需要从磁盘加载 image.display(); System.out.println(&quot;&quot;); // 图像不需要从磁盘加载 image.display(); &#125;&#125; 输出结果1234第一次从加载对象 fengx.jpg展示：fengx.jpg展示：fengx.jpg","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"开发必备----Linux","slug":"linux1","date":"2021-01-28T02:04:25.000Z","updated":"2021-08-14T03:37:30.388Z","comments":false,"path":"2021/01/28/linux1/","link":"","permalink":"http://example.com/2021/01/28/linux1/","excerpt":"","text":"Linux系统目录1234567891011121314/ -- 根目录├── bin -- 大部分系统命令├── sbin -- 超级用户才能执行的命令目录├── boot -- 系统启动相关目录├── dev -- 设备文件目录├── etc -- 配置文件目录├── home -- 普通用户的目录（一个用户对应一个文件夹）├── lib 、lib64 -- 库文件、64位库文件├── lost+found -- 系统异常时临时保存的数据，用于恢复等操作├── media -- 媒体目录├── mnt -- 挂载目录，通用挂载点├── opt -- 安装系统非必需的软件的目录（应用软件安装目录）├── root -- root用户的家目录└── usr -- 存放用户安装的应用程序 系统服务管理systemctl systemctl命令是service和chkconfig命令的组合体，可用于管理系统。 输出系统中各个服务的状态 1systemctl list-units --type=service 查看服务的运行状态 1systemctl status firewalld 关闭服务 1systemctl stop firewalld 启动服务 1systemctl start firewalld 重新启动服务（不管当前服务是启动还是关闭） 1systemctl restart firewalld 重新载入配置信息而不中断服务 1systemctl reload firewalld 禁止服务开机自启动 1systemctl disable firewalld 设置服务开机自启动 1systemctl enable firewalld 文件管理ls列出指定目录下的所有文件，列出/目录下的文件 1ls -l / pwd获取目前所在工作目录的绝对路径 1pwd cd改变当前工作目录 1cd /usr/local date显示或修改系统时间与日期 1date &#x27;+%Y-%m-%d %H:%M:%S&#x27; passwd用于设置用户密码 1passwd root su改变用户身份（切换到超级用户） 1su clear用于清除屏幕信息 1clear man显示指定命令的帮助信息 1man ls who显示目前登录到系统的用户 1who -buT free显示系统内存状态（单位MB） 1free -m ps显示系统进程运行动态 1ps -ef 端口查看所有应用占用端口情况 1netstat -ap 查找8080端口是否被占用 1netstat -ap |grep 8080 进程查看所有进程 1ps -ef 查看tomcat进程 1ps -ef |grep tomcat （输出如下 *** 5144 。。。等等.Bootstrap start 说明tomcat已经正常启动， 5144 就为进程号 pid = 5144） 查看监听进程号 1netstat -anp|grep pid 杀死进程 1kill -9 5144 查看sshd进程的运行动态 1ps -ef | grep sshd top查看即时活跃的进程，类似Windows的任务管理器 1top mkdir创建目录 1mkdir /usr/newdir more用于分页查看文件，例如每页10行查看boot.log文件 1more -c -10 /var/log/boot.log cat用于查看文件，例如查看Linux启动日志文件文件，并标明行号 1cat -Ab /var/log/boot.log touch用于创建文件，例如创建text.txt文件 1touch text.txt rm删除文件 1rm text.txt 强制删除某个目录及其子目录 1rm -rf testdir/ cp用于拷贝文件，例如将test1目录复制到test2目录 1cp -r /mydata/tes1 /mydata/test2 mv用于移动或覆盖文件 1mv text.txt text2.txt 压缩与解压tar将/etc文件夹中的文件归档到文件etc.tar（并不会进行压缩） 1tar -cvf /mydata/etc.tar /etc 用gzip压缩文件夹/etc中的文件到文件etc.tar.gz 1tar -zcvf /mydata/etc.tar.gz /etc 用bzip2压缩文件夹/etc到文件/etc.tar.bz2 1tar -jcvf /mydata/etc.tar.bz2 /etc 分页查看压缩包中内容（gzip） 1tar -ztvf /mydata/etc.tar.gz |more -c -10 解压文件到当前目录（gzip） 1tar -zxvf /mydata/etc.tar.gz 解压文件到指定目录（gzip） 1tar -zxvf /mydata/etc.tar.gz -C /mydata/etc 终端编辑器vi/vim(需要安装) 1yum install -y vim 打开/创建文件 1vim hello.txt 编辑模式 按任意键开始编辑 正常模式 esc 保存、退出 shift + : w–保存q–退出wq–保存并退出q!–强制退出set nu–显示行号set nonu–隐藏行号 注意若非正常关闭vim，则会生成临时文件（隐藏的），需要删除 磁盘和网络管理df查看磁盘空间占用情 1df -hT du查看当前目录下的文件及文件夹所占大小 1du -h --max-depth=1 ./* ifconfig显示当前网络接口状态 1ifconfig netstat查看当前路由信息 1netstat -rn 查看所有有效TCP连接 1netstat -an 查看系统中启动的监听服务 1netstat -tulnp 查看处于连接状态的系统资源信息 1netstat -atunp wget从网络上下载文件 文件上传下载安装上传下载工具lrzsz 1yum install -y lrzsz 上传文件，输入以下命令XShell会弹出文件上传框 1rz 下载文件，输入以下命令XShell会弹出文件保存框 1sz fileName 软件的安装与管理rpm RPM是Red-Hat Package Manager的缩写，一种Linux下通用的软件包管理方式，可用于安装和管理.rpm结尾的软件包。 安装软件包 1rpm -ivh nginx-1.12.2-2.el7.x86_64.rpm 模糊搜索软件包 1rpm -qa | grep nginx 精确查找软件包 1rpm -qa nginx 查询软件包的安装路径 1rpm -ql nginx-1.12.2-2.el7.x86_64 查看软件包的概要信息 1rpm -qi nginx-1.12.2-2.el7.x86_64 验证软件包内容和安装文件是否一致 1rpm -V nginx-1.12.2-2.el7.x86_64 更新软件包 1rpm -Uvh nginx-1.12.2-2.el7.x86_64 删除软件包 1rpm -e nginx-1.12.2-2.el7.x86_64 yum Yum是Yellow dog Updater, Modified的缩写，能够在线自动下载RPM包并安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，非常方便！ 安装软件包 1yum install nginx 检查可以更新的软件包 1yum check-update 更新指定的软件包 1yum update nginx 在资源库中查找软件包信息 1yum info nginx* 列出已经安装的所有软件包 1yum info installed 列出软件包名称 1yum list nginx* 模糊搜索软件包 1yum search nginx","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"keywords":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}]},{"title":"MySQL建表规约整理-《Java开发手册》","slug":"database1","date":"2021-01-24T06:29:21.000Z","updated":"2021-08-13T15:42:55.819Z","comments":false,"path":"2021/01/24/database1/","link":"","permalink":"http://example.com/2021/01/24/database1/","excerpt":"","text":"建库1、库名与应用名称尽量一致 建表1、表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明：MySQL 在 Windows下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例：aliyun_admin，rdc_config，level3_name 反例：AliyunAdmin，rdcConfig，level_3_name 2、表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。 3、表的命名最好是遵循“业务名称_表的作用”。 正例：alipay_task / force_project / trade_config 建字段 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 1、数据表必备三字段：id, create_time, update_time。 说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time, update_time的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。 是与否类型字段1、表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。 说明：任何字段如果为非负数，必须是unsigned。 注意：POJO类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在设置从 is_xxx 到Xxx的映射关系。数据库表示是与否的值，使用 tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围。 正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 普通字段1、禁用保留字，如desc、range、match、delayed 等，请参考 MySQL 官方保留字。 2、如果存储的字符串长度几乎相等，使用char 定长字符串类型。 索引字段1、主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。 说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称 数字字段1、小数类型为 decimal，禁止使用 float 和 double。 说明：在存储的时候，float 和 double都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。 长字段1、varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 改字段1、如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 冗余字段1、字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循 不是频繁修改的字段。 不是唯一索引的字段。 不是 varchar 超长字段，更不能是text字段。 正例：各业务线经常冗余存储商品名称，避免查询时需要调用 IC 服务获取 分库分表1、单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}]}